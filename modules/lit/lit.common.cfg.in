# Copyright (C) Codeplay Software Limited
#
# Licensed under the Apache License, Version 2.0 (the "License") with LLVM
# Exceptions; you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://github.com/codeplaysoftware/oneapi-construction-kit/blob/main/LICENSE.txt
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.
#
# SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
# @AUTOGENERATED_MESSAGE@

import lit.util
import re
from subprocess import check_output
from platform import system, machine

from lit.llvm.subst import ToolSubst, FindTool

import lit.llvm
lit.llvm.initialize(lit_config, config)
from lit.llvm import llvm_config

def if_enabled(config, if_true=True, if_false=False):
    return lit.util.pythonize_bool(config) and if_true or if_false

config.system_processor = '@CMAKE_SYSTEM_PROCESSOR@'.lower()

config.ca_cross_compiled = if_enabled('@CMAKE_CROSSCOMPILING@')

if '@LLVM_VERSION_MAJOR@':
    config.llvm_version_triple = (
        int(@LLVM_VERSION_MAJOR@),
        int(@LLVM_VERSION_MINOR@),
        int(@LLVM_VERSION_PATCH@),
    )
    config.llvm_version_major = int(@LLVM_VERSION_MAJOR@)
    config.substitutions.append(('%LLVMVER', '@LLVM_VERSION_MAJOR@'))

    config.available_features.add('llvm')
    config.available_features.add('llvm-@LLVM_VERSION_MAJOR@.@LLVM_VERSION_MINOR@-only')

    # Add all previous LLVM major versions as features too, e.g., llvm-10+
    # matches on LLVMs 10,11,12,13 and onwards.
    for ver in range(8, @LLVM_VERSION_MAJOR@ + 1):
        config.available_features.add('llvm-{0}+'.format(ver))

config.targets = frozenset('@LLVM_TARGETS_TO_BUILD@'.split(','))

config.llvm_enable_stats = (
    if_enabled('@LLVM_ENABLE_ASSERTIONS@') or
    if_enabled('@LLVM_FORCE_ENABLE_STATS@')
)

if if_enabled('@LLVM_ENABLE_ASSERTIONS@'):
    config.available_features.add('asserts')

# Some lit tests may fail when cross-compiled, so add the native feature if not
# cross-compiling.
if not config.ca_cross_compiled:
    config.available_features.add('native')

def is_compile_flag_defined(options_str, flag):
    is_enabled = False
    opts = options_str.split()
    for i, opt in enumerate(opts):
        if opt in (f'-D{flag}', f'/D{flag}') or \
                (opt == '/D' and i + 1 < len(opts) and opts[i + 1] == flag):
            is_enabled = True
        elif opt == f'-U{flag}':
            is_enabled = False
    return is_enabled

cmake_cxx_flags = '@CMAKE_CXX_FLAGS@'

if not is_compile_flag_defined(cmake_cxx_flags, 'NDEBUG') or if_enabled('@CA_ENABLE_LLVM_OPTIONS_IN_RELEASE@'):
    config.available_features.add('ca_llvm_options')

if system() == 'Linux':
    config.available_features.add('linux')
elif system() == 'arm':
    config.available_features.add('arm')

if config.system_processor in ('x86_64', 'x64', 'amd64'):
    config.available_features.add('x86_64')
elif config.system_processor in ('x86', 'i686'):
    config.available_features.add('x86')
elif config.system_processor in ('aarch64', 'arm64'):
    config.available_features.add('aarch64')
elif config.system_processor in ('arm', 'armv7'):
    config.available_features.add('arm32')

config.ca_host_os = '@CMAKE_SYSTEM_NAME@'

config.ca_host_bits = 64 if (
    @CMAKE_SIZEOF_VOID_P@ == 8 and
    ('@CA_BUILD_32_BITS@' != 'ON' or '@CMAKE_CL_64@' == '1')
) else 32


# Check we can find helper tools, otherwise raise an exception
# to prevent any tests running.

# We allow sites to define config.tools first, but don't require it.
if 'tools' not in vars(config):
    config.tools = []

# Extend any site tool with our standard set of tools. If any of these are
# missing, we mark the whole test suite as unsupported.
config.tools.extend([
    ToolSubst('not', unresolved='ignore'),
    ToolSubst('FileCheck', unresolved='ignore'),
    ToolSubst('llc', unresolved='ignore'),
    ToolSubst('llvm-as', unresolved='ignore'),
    ToolSubst('llvm-dis', unresolved='ignore'),
])

# Check at runtime if environmental variables have been set with paths to
# helper tools. If so, set the 'command' flag, which tells lit to treat the
# tool command as an exact path.
for tool in config.tools:
    env_var = os.environ.get(f'LIT_{tool.key.upper().replace("-", "_")}')
    if env_var:
        tool.command = env_var

# The add_tool_substitutions functiom below requires us to have a
# llvm_tools_dir set, so we set it to the most sensible choice of the tool
# directories we search.
config.llvm_tools_dir = '@CA_LLVM_TOOLS_DIR@'

# Try and find each of these tools in the various tools directories or the
# PATH, in that order. If found, they will be added as substitutions with the
# full path to the tool. This allows us to support both in-tree builds and
# standalone builds, where the tools may be externally defined.
search_dirs = [
    '@PROJECT_BINARY_DIR@/bin', '@CA_BUILTINS_TOOLS_DIR@',
     config.llvm_tools_dir, os.environ.get('PATH', ''),
]

llvm_config.add_tool_substitutions(config.tools, search_dirs)

def last_substitution_by_key(li, x):
    for i in reversed(range(len(li))):
      if li[i][0] == x:
          return i
    return -1

def is_native_exe(path):
    """Determines if an executable is native."""
    # We currently do not support cross compilation and emulated testing on
    # windows meaning on windows builds everything is native.
    if 'Windows' == system():
        return True
    output = str(check_output(['file', path]))
    # If the BuildID hash happens to end up having '386' in it then it can
    # cause a false match below, so just blank out any BuildID.
    cleaned = re.sub(r"BuildID\[[\w\s]*\]=[A-Fa-f0-9]*, ","", output)
    if 'x86' in machine() or '386' in machine():
        if 'x86' in cleaned or '386' in cleaned:
            return True
        return False
    return True

# Handle emulation of non-native tools by preprending any substitution with the
# emulator command.
for tool in config.tools:
    if not tool.was_resolved:
        continue
    idx = last_substitution_by_key(config.substitutions, tool.regex)
    if idx < 0:
        continue
    subst_key = config.substitutions[idx][0]
    subst_path = config.substitutions[idx][1]
    if 'emulator' in lit_config.params and not is_native_exe(subst_path):
        config.substitutions[idx]= (subst_key, f'{lit_config.params["emulator"]} {subst_path}')

missing_tools = [tool.key for tool in config.tools if not tool.was_resolved]

if missing_tools:
    lit_config.note(f'Skipping test suite: did not find {",".join(missing_tools)} in {search_dirs}')
    config.unsupported = True

config.substitutions += [
    ('%python', sys.executable),
    ('%pp-llvm-ver', '%s %s' % (
        sys.executable,
        os.path.join('@PROJECT_SOURCE_DIR@', 'scripts', 'testing', 'pp-llvm-ver.py')
    ))
]
