# Copyright Codeplay Software Limited. All rights reserved
# @AUTOGENERATED_MESSAGE@

import lit.util
import re
from subprocess import check_output
from platform import system, machine

def if_enabled(config, if_true=True, if_false=False):
    return lit.util.pythonize_bool(config) and if_true or if_false

config.system_processor = '@CMAKE_SYSTEM_PROCESSOR@'.lower()

config.ca_cross_compiled = if_enabled('@CMAKE_CROSSCOMPILING@')

if '@LLVM_VERSION_MAJOR@':
    config.llvm_version_triple = (
        int(@LLVM_VERSION_MAJOR@),
        int(@LLVM_VERSION_MINOR@),
        int(@LLVM_VERSION_PATCH@),
    )
    config.llvm_version_major = int(@LLVM_VERSION_MAJOR@)
    config.substitutions.append(('%LLVMVER', '@LLVM_VERSION_MAJOR@'))

    config.available_features.add('llvm')
    config.available_features.add('llvm-@LLVM_VERSION_MAJOR@.@LLVM_VERSION_MINOR@-only')

    # Add all previous LLVM major versions as features too, e.g., llvm-10+
    # matches on LLVMs 10,11,12,13 and onwards.
    for ver in range(8, @LLVM_VERSION_MAJOR@ + 1):
        config.available_features.add('llvm-{0}+'.format(ver))

config.targets = frozenset('@LLVM_TARGETS_TO_BUILD@'.split(','))

config.llvm_enable_stats = (
    if_enabled('@LLVM_ENABLE_ASSERTIONS@') or
    if_enabled('@LLVM_FORCE_ENABLE_STATS@')
)

if if_enabled('@LLVM_ENABLE_ASSERTIONS@'):
    config.available_features.add('asserts')

# Some lit tests may fail when cross-compiled, so add the native feature if not
# cross-compiling.
if not config.ca_cross_compiled:
    config.available_features.add('native')

def is_compile_flag_defined(options_str, flag):
    is_enabled = False
    opts = options_str.split()
    for i, opt in enumerate(opts):
        if opt in (f'-D{flag}', f'/D{flag}') or \
                (opt == '/D' and i + 1 < len(opts) and opts[i + 1] == flag):
            is_enabled = True
        elif opt == f'-U{flag}':
            is_enabled = False
    return is_enabled

cmake_cxx_flags = '@CMAKE_CXX_FLAGS@'

if not is_compile_flag_defined(cmake_cxx_flags, 'NDEBUG') or if_enabled('@CA_ENABLE_LLVM_OPTIONS_IN_RELEASE@'):
    config.available_features.add('ca_llvm_options')

if system() == 'Linux':
    config.available_features.add('linux')
elif system() == 'arm':
    config.available_features.add('arm')

if config.system_processor in ('x86_64', 'x64', 'amd64'):
    config.available_features.add('x86_64')
elif config.system_processor in ('x86', 'i686'):
    config.available_features.add('x86')
elif config.system_processor in ('aarch64', 'arm64'):
    config.available_features.add('aarch64')
elif config.system_processor in ('arm', 'armv7'):
    config.available_features.add('arm32')

config.ca_host_os = '@CMAKE_SYSTEM_NAME@'

config.ca_host_bits = 64 if (
    @CMAKE_SIZEOF_VOID_P@ == 8 and
    ('@CA_BUILD_32_BITS@' != 'ON' or '@CMAKE_CL_64@' == '1')
) else 32


def is_native_exe(path):
    """Determines if an executable is native."""
    # We currently do not support cross compilation and emulated testing on
    # windows meaning on windows builds everything is native.
    if 'Windows' == system():
        return True
    output = str(check_output(['file', path]))
    # If the BuildID hash happens to end up having '386' in it then it can
    # cause a false match below, so just blank out any BuildID.
    cleaned = re.sub(r"BuildID\[[\w\s]*\]=[A-Fa-f0-9]*, ","", output)
    if 'x86' in machine() or '386' in machine():
        if 'x86' in cleaned or '386' in cleaned:
            return True
        return False
    return True


# Check we can find helper tools, otherwise raise an exception
# to prevent any tests running.

# First, update provides tool paths with common lit tools
config.tool_paths.update({
    'not': '@not_EXECUTABLE@',
    'filecheck': '@FileCheck_EXECUTABLE@',
    'llc': '@llc_EXECUTABLE@',
    'cov': '@llvm-cov_EXECUTABLE@',
    'llvm-as': '@llvm-as_EXECUTABLE@',
    'llvm-dis': '@llvm-dis_EXECUTABLE@',
    'profdata': '@llvm-profdata_EXECUTABLE@',
})

# Check at runtime if environmental variables have been set
# with paths to helper tools. This is useful when testing on
# jenkins where the executables may have been built on a different
# physical machine.
config.tool_paths = {
    key: os.environ.get(f'LIT_{key.upper()}', val)
    for key, val in config.tool_paths.items()
}

for key, path in config.tool_paths.items():
    if not lit.util.which(path):
        lit_config.fatal(f'Could not find {key} in path {path}')
    if is_native_exe(path):
        config.substitutions.append(('%' + key, path))
    elif 'emulator' in lit_config.params:
        config.substitutions.append(
            ('%' + key, '%s %s' % (lit_config.params['emulator'], path)))
    else:
        lit_config.fatal(
            '%s is not a native exectuable and no emulator provided' % path)

config.substitutions += [
    ('%python', sys.executable),
    ('%pp-llvm-ver', '%s %s' % (
        sys.executable,
        os.path.join('@PROJECT_SOURCE_DIR@', 'scripts', 'testing', 'pp-llvm-ver.py')
    ))
]
