diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
index 00000000..f23f42f0
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,46 @@
+# Copyright (C) Codeplay Software Limited. All Rights Reserved.
+
+cmake_minimum_required(VERSION 3.0.0)
+
+if(CMAKE_SOURCE_DIR STREQUAL CMAKE_CURRENT_SOURCE_DIR)
+  project(Spike VERSION 1.0.1)
+
+  if(CMAKE_SOURCE_DIR STREQUAL CMAKE_BINARY_DIR)
+    message(FATAL_ERROR "In-tree builds are not supported")
+  endif()
+
+  set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/bin)
+  set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/lib)
+  set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/lib)
+endif()
+set(SPIKE_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR})
+set(SPIKE_BINARY_DIR ${CMAKE_CURRENT_BINARY_DIR})
+
+# Generate config.h
+include(CheckIncludeFiles)
+include(CheckLibraryExists)
+check_include_files("inttypes.h" HAVE_INTTYPES_H)
+check_include_files("memory.h" HAVE_MEMORY_H)
+check_include_files("stdint.h" HAVE_STDINT_H)
+check_include_files("stdlib.h" HAVE_STDLIB_H)
+check_include_files("strings.h" HAVE_STRINGS_H)
+check_include_files("string.h" HAVE_STRING_H)
+check_include_files("sys/stat.h" HAVE_SYS_STAT_H)
+check_include_files("sys/types.h" HAVE_SYS_TYPES_H)
+check_include_files("unistd.h" HAVE_UNISTD_H)
+check_include_files("stdlib.h;stdarg.h;string.h;float.h" STDC_HEADERS)
+check_library_exists(pthread "pthread_create" "" HAVE_LIBPTHREAD)
+set(DEFAULT_ISA "RV64IMAFDC" CACHE STRING "Default value for --isa switch")
+set(DEFAULT_PRIV "MSU" CACHE STRING "Default value for --priv switch")
+set(DEFAULT_VARCH "vlen:128,elen:64,slen:128" CACHE STRING "Default value for --vector switch")
+set(DTC "dtc" CACHE STRING "Path to the device-tree-compiler")
+set(SOFTFLOAT_ENABLED 1)
+set(SPIKE_MAIN_ENABLED 1)
+set(RISCV_ENABLED 1)
+configure_file(cmake-config.h.in ${SPIKE_BINARY_DIR}/config.h)
+
+add_subdirectory(softfloat)
+add_subdirectory(fesvr)
+add_subdirectory(fdt)
+add_subdirectory(riscv)
+add_subdirectory(spike_main)
diff --git a/cmake-config.h.in b/cmake-config.h.in
new file mode 100644
index 00000000..fa8e852c
--- /dev/null
+++ b/cmake-config.h.in
@@ -0,0 +1,106 @@
+/* cmake-config.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define if building universal (internal helper macro) */
+#cmakedefine AC_APPLE_UNIVERSAL_BUILD @AC_APPLE_UNIVERSAL_BUILD@
+
+/* Default value for --isa switch */
+#cmakedefine DEFAULT_ISA "@DEFAULT_ISA@"
+
+/* Default value for --priv switch */
+#cmakedefine DEFAULT_PRIV "@DEFAULT_PRIV@"
+
+/* Default value for --vector switch */
+#cmakedefine DEFAULT_VARCH "@DEFAULT_VARCH@"
+
+/* Path to the device-tree-compiler */
+#cmakedefine DTC "@DTC@"
+
+/* Define if subproject MCPPBS_SPROJ_NORM is enabled */
+#cmakedefine DUMMY_ROCC_ENABLED @DUMMY_ROCC_ENABLED@
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#cmakedefine HAVE_INTTYPES_H @HAVE_INTTYPES_H@
+
+/* Define to 1 if you have the `fesvr' library (-lfesvr). */
+#cmakedefine HAVE_LIBFESVR @HAVE_LIBFESVR@
+
+/* Define to 1 if you have the `pthread' library (-lpthread). */
+#cmakedefine HAVE_LIBPTHREAD @HAVE_LIBPTHREAD@
+
+/* Define to 1 if you have the <memory.h> header file. */
+#cmakedefine HAVE_MEMORY_H @HAVE_MEMORY_H@
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#cmakedefine HAVE_STDINT_H @HAVE_STDINT_H@
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#cmakedefine HAVE_STDLIB_H @HAVE_STDLIB_H@
+
+/* Define to 1 if you have the <strings.h> header file. */
+#cmakedefine HAVE_STRINGS_H @HAVE_STRINGS_H@
+
+/* Define to 1 if you have the <string.h> header file. */
+#cmakedefine HAVE_STRING_H @HAVE_STRING_H@
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#cmakedefine HAVE_SYS_STAT_H @HAVE_SYS_STAT_H@
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#cmakedefine HAVE_SYS_TYPES_H @HAVE_SYS_TYPES_H@
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#cmakedefine HAVE_UNISTD_H @HAVE_UNISTD_H@
+
+/* Define to the address where bug reports for this package should be sent. */
+#cmakedefine PACKAGE_BUGREPORT @PACKAGE_BUGREPORT@
+
+/* Define to the full name of this package. */
+#cmakedefine PACKAGE_NAME @PACKAGE_NAME@
+
+/* Define to the full name and version of this package. */
+#cmakedefine PACKAGE_STRING @PACKAGE_STRING@
+
+/* Define to the one symbol short name of this package. */
+#cmakedefine PACKAGE_TARNAME @PACKAGE_TARNAME@
+
+/* Define to the home page for this package. */
+#cmakedefine PACKAGE_URL @PACKAGE_URL@
+
+/* Define to the version of this package. */
+#cmakedefine PACKAGE_VERSION @PACKAGE_VERSION@
+
+/* Define if subproject MCPPBS_SPROJ_NORM is enabled */
+#cmakedefine RISCV_ENABLED @RISCV_ENABLED@
+
+/* Enable commit log generation */
+#cmakedefine RISCV_ENABLE_COMMITLOG @RISCV_ENABLE_COMMITLOG@
+
+/* Enable hardware management of PTE accessed and dirty bits */
+#cmakedefine RISCV_ENABLE_DIRTY @RISCV_ENABLE_DIRTY@
+
+/* Enable PC histogram generation */
+#cmakedefine RISCV_ENABLE_HISTOGRAM @RISCV_ENABLE_HISTOGRAM@
+
+/* Enable hardware support for misaligned loads and stores */
+#cmakedefine RISCV_ENABLE_MISALIGNED @RISCV_ENABLE_MISALIGNED@
+
+/* Define if subproject MCPPBS_SPROJ_NORM is enabled */
+#cmakedefine SOFTFLOAT_ENABLED @SOFTFLOAT_ENABLED@
+
+/* Define if subproject MCPPBS_SPROJ_NORM is enabled */
+#cmakedefine SPIKE_MAIN_ENABLED @SPIKE_MAIN_ENABLED@
+
+/* Define to 1 if you have the ANSI C header files. */
+#cmakedefine STDC_HEADERS @STDC_HEADERS@
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+#cmakedefine WORDS_BIGENDIAN @WORDS_BIGENDIAN@
+# endif
+#endif
diff --git a/fdt/CMakeLists.txt b/fdt/CMakeLists.txt
new file mode 100644
index 00000000..80337752
--- /dev/null
+++ b/fdt/CMakeLists.txt
@@ -0,0 +1,18 @@
+# Copyright (C) Codeplay Software Limited. All Rights Reserved.
+
+add_library(fdt
+  STATIC
+  fdt.c
+  fdt_ro.c
+  fdt_wip.c
+  fdt_sw.c
+  fdt_rw.c
+  fdt_strerror.c
+  fdt_empty_tree.c
+  fdt_addresses.c
+  fdt_overlay.c
+)
+
+target_include_directories(fdt PUBLIC
+    ${CMAKE_CURRENT_SOURCE_DIR}
+)
diff --git a/fesvr/CMakeLists.txt b/fesvr/CMakeLists.txt
new file mode 100644
index 00000000..fc968513
--- /dev/null
+++ b/fesvr/CMakeLists.txt
@@ -0,0 +1,37 @@
+# Copyright (C) Codeplay Software Limited. All Rights Reserved.
+
+add_library(fesvr
+  STATIC
+  context.cc
+  device.cc
+  dtm.cc
+  dummy.cc
+  elf2hex.cc
+  elfloader.cc
+  htif.cc
+  htif_hexwriter.cc
+  htif_pthread.cc
+  memif.cc
+  option_parser.cc
+  rfb.cc
+  syscall.cc
+  term.cc
+  tsi.cc
+)
+
+target_include_directories(fesvr PUBLIC
+    ${CMAKE_CURRENT_SOURCE_DIR}
+    ${SPIKE_SOURCE_DIR} # Other subprojects use <fesvr/foo.h> includes
+)
+
+target_include_directories(fesvr PRIVATE
+    ${SPIKE_SOURCE_DIR}/riscv
+    ${SPIKE_BINARY_DIR} # generated headers like config.h and icache.h
+    ${SPIKE_SOURCE_DIR}/softfloat
+)
+
+target_compile_definitions(fesvr PRIVATE
+    -DPREFIX="${CMAKE_INSTALL_PREFIX}"
+)
+
+target_link_libraries(fesvr PRIVATE pthread)
diff --git a/riscv/CMakeLists.txt b/riscv/CMakeLists.txt
new file mode 100644
index 00000000..5e5047c3
--- /dev/null
+++ b/riscv/CMakeLists.txt
@@ -0,0 +1,58 @@
+# Copyright (C) Codeplay Software Limited. All Rights Reserved.
+
+# Compile all instructions.
+set(INSN_DIR ${CMAKE_CURRENT_BINARY_DIR}/insn)
+set(INSN_SOURCE_FILE ${INSN_DIR}/insns.cc)
+set(INSN_HEADER_FILE ${SPIKE_BINARY_DIR}/insn_list.h)
+set(INSN_TEMPLATE ${CMAKE_CURRENT_SOURCE_DIR}/insn_template.cc)
+set(INSN_ENCODING ${CMAKE_CURRENT_SOURCE_DIR}/encoding.h)
+set(INSN_GEN_SCRIPT ${CMAKE_CURRENT_SOURCE_DIR}/generate_insn.py)
+file(MAKE_DIRECTORY ${INSN_DIR})
+
+add_custom_command(OUTPUT ${INSN_SOURCE_FILE} ${INSN_HEADER_FILE}
+                   COMMAND /usr/bin/python3 "${INSN_GEN_SCRIPT}" "${CMAKE_CURRENT_SOURCE_DIR}" "${INSN_SOURCE_FILE}" "${INSN_HEADER_FILE}"
+                   DEPENDS ${INSN_GEN_SCRIPT} ${INSN_TEMPLATE} ${INSN_ENCODING})
+
+add_library(riscv-sim
+  STATIC
+  cachesim.cc
+  clint.cc
+  csrs.cc
+  debug_module.cc
+  devices.cc
+  dts.cc
+  execute.cc
+  extension.cc
+  extensions.cc
+  interactive.cc
+  isa_parser.cc
+  jtag_dtm.cc
+  mmu.cc
+  processor.cc
+  profiler.cc
+  ${CMAKE_CURRENT_SOURCE_DIR}/../disasm/regnames.cc
+  remote_bitbang.cc
+  rocc.cc
+  rom.cc
+  sim.cc
+  triggers.cc
+  ${CMAKE_CURRENT_SOURCE_DIR}/../disasm/disasm.cc
+  ${INSN_SOURCE_FILE}
+)
+
+# Generate icache.h
+set(ICACHE_HEADER_FILE ${SPIKE_BINARY_DIR}/icache.h)
+set(MMU_HEADER_FILE ${CMAKE_CURRENT_SOURCE_DIR}/mmu.h)
+set(ICACHE_GEN_SCRIPT ${CMAKE_CURRENT_SOURCE_DIR}/generate_icache.py)
+add_custom_command(OUTPUT ${ICACHE_HEADER_FILE}
+                   COMMAND /usr/bin/python3 "${ICACHE_GEN_SCRIPT}" "${MMU_HEADER_FILE}" "${ICACHE_HEADER_FILE}"
+                   DEPENDS ${ICACHE_GEN_SCRIPT} ${MMU_HEADER_FILE})
+add_custom_target(riscv-headers ALL DEPENDS ${ICACHE_HEADER_FILE})
+add_dependencies(riscv-sim riscv-headers)
+
+target_include_directories(riscv-sim PUBLIC
+    ${CMAKE_CURRENT_SOURCE_DIR}
+    ${SPIKE_BINARY_DIR} # generated headers like config.h and icache.h
+)
+
+target_link_libraries(riscv-sim fesvr softfloat fdt)
diff --git a/riscv/decode.h b/riscv/decode.h
index e0d70bfa..46308f85 100644
--- a/riscv/decode.h
+++ b/riscv/decode.h
@@ -14,8 +14,8 @@
 #include "encoding.h"
 #include "config.h"
 #include "common.h"
-#include "softfloat_types.h"
-#include "specialize.h"
+#include "../softfloat/softfloat_types.h"
+#include "../softfloat/specialize.h"
 #include <cinttypes>
 
 typedef int64_t sreg_t;
@@ -142,7 +142,7 @@ public:
 private:
   insn_bits_t b;
   uint64_t x(int lo, int len) { return (b >> lo) & ((insn_bits_t(1) << len)-1); }
-  uint64_t xs(int lo, int len) { return int64_t(b) << (64-lo-len) >> (64-len); }
+  uint64_t xs(int lo, int len) { return int64_t(b << (64-lo-len)) >> (64-len); }
   uint64_t imm_sign() { return xs(63, 1); }
 };
 
diff --git a/riscv/execute.cc b/riscv/execute.cc
index 98e3cdb0..e627b914 100644
--- a/riscv/execute.cc
+++ b/riscv/execute.cc
@@ -2,6 +2,7 @@
 
 #include "processor.h"
 #include "mmu.h"
+#include "profiler.h"
 #include "disasm.h"
 #include <cassert>
 
@@ -215,7 +216,8 @@ static inline reg_t execute_insn(processor_t* p, reg_t pc, insn_fetch_t fetch)
 
 bool processor_t::slow_path()
 {
-  return debug || state.single_step != state.STEP_NONE || state.debug_mode;
+  return debug || state.single_step != state.STEP_NONE || state.debug_mode ||
+         state.profiler_mode;
 }
 
 // fetch/decode/execute loop
@@ -261,6 +263,11 @@ void processor_t::step(size_t n)
         // Main simulation loop, slow path.
         while (instret < n)
         {
+          if (unlikely(state.bp_addr == pc)) {
+            state.minstret->bump(instret);
+            state.mcycle->bump(instret);
+            return;
+          }
           if (unlikely(!state.serialized && state.single_step == state.STEP_STEPPED)) {
             state.single_step = state.STEP_NONE;
             if (!state.debug_mode) {
@@ -277,6 +284,8 @@ void processor_t::step(size_t n)
           insn_fetch_t fetch = mmu->load_insn(pc);
           if (debug && !state.serialized)
             disasm(fetch.insn);
+          if (state.profiler_mode)
+            profiler->run(*this, fetch.insn, xlen);
           pc = execute_insn(this, pc, fetch);
           advance_pc();
         }
@@ -286,6 +295,11 @@ void processor_t::step(size_t n)
         // Main simulation loop, fast path.
         for (auto ic_entry = _mmu->access_icache(pc); ; ) {
           auto fetch = ic_entry->data;
+          if (unlikely(state.bp_addr == pc)) {
+            state.minstret->bump(instret);
+            state.mcycle->bump(instret);
+            return;
+          }
           pc = execute_insn(this, pc, fetch);
           ic_entry = ic_entry->next;
           if (unlikely(ic_entry->tag != pc))
diff --git a/riscv/generate_icache.py b/riscv/generate_icache.py
new file mode 100644
index 00000000..7a57ab0d
--- /dev/null
+++ b/riscv/generate_icache.py
@@ -0,0 +1,36 @@
+#!/usr/bin/env python3
+
+# Copyright (C) Codeplay Software Limited. All Rights Reserved.
+
+import sys
+import re
+
+def main(argv):
+    if len(argv) != 3:
+        sys.stderr.write("usage: {} <MMU header> <output header>\n".format(argv[0]))
+        return 1
+    input_header_path = argv[1]
+    output_header_path = argv[2]
+
+    # Read the input header.
+    entries_regex = re.compile(r"ICACHE_ENTRIES = (\d+);\s*$")
+    num_icache_entries = None
+    with open(input_header_path, "r") as f:
+        for line in f:
+            m = entries_regex.search(line)
+            if m:
+                num_icache_entries = int(m.group(1))
+                break
+    if num_icache_entries is None:
+        sys.stderr.write("error: could not find 'ICACHE_ENTRIES' definition in '{}'\n".format(input_header_path))
+        return 1
+
+    # Generate the output header.
+    with open(output_header_path, "w") as f:
+        for i in range(0, num_icache_entries):
+            f.write("case {0}: ICACHE_ACCESS({0});\n".format(i))
+
+    return 0
+
+if __name__ == "__main__":
+    sys.exit(main(sys.argv))
diff --git a/riscv/generate_insn.py b/riscv/generate_insn.py
new file mode 100644
index 00000000..29f166e7
--- /dev/null
+++ b/riscv/generate_insn.py
@@ -0,0 +1,115 @@
+#!/usr/bin/env python3
+
+# Copyright (C) Codeplay Software Limited. All Rights Reserved.
+
+import os
+import sys
+import re
+
+def read_encoding_table(path):
+    instructions = {}
+    with open(path, "r") as f:
+        for line in f:
+            m = re.match("DECLARE_INSN\((\w+), (\w+), (\w+)\)", line)
+            if not m:
+                continue
+            instructions[m.group(1)] = m.groups()
+    return instructions
+
+
+def load_template(template_path):
+    with open(template_path, "r") as f:
+        template = f.read()
+
+    # Separate the body of the template from the header.
+    lines = template.split("\n")
+    body_start_line = None
+    for i, line in enumerate(lines):
+        if line.find("(") >= 0:
+            body_start_line = i
+            break
+    if body_start_line is not None:
+        return "\n".join(lines[0:body_start_line]), "\n".join(lines[body_start_line:])
+    else:
+        return "", template
+
+
+def generate_from_template(template, instruction):
+    output = template.replace("NAME", instruction[0])
+    output = output.replace("OPCODE", instruction[1])
+    return output
+
+
+def main(argv):
+    if len(argv) != 4 and len(argv) != 5:
+        sys.stderr.write("usage: {} <source dir> <output source> <output header> [<instruction name>]\n".format(argv[0]))
+        return 1
+    source_dir = argv[1]
+    output_path = argv[2]
+    header_path = argv[3]
+    instruction_name = None
+    if len(argv) >= 5:
+        instruction_name = argv[4]
+
+    # Read the template.
+    template_file = os.path.join(source_dir, "insn_template.cc")
+    if not os.path.exists(template_file):
+        sys.stderr.write("error: file not found: '{}'\n".format(template_file))
+        return 1
+    template_header, template_body = load_template(template_file)
+
+    # Read the instruction table.
+    encoding_file = os.path.join(source_dir, "encoding.h")
+    if not os.path.exists(encoding_file):
+        sys.stderr.write("error: file not found: '{}'\n".format(encoding_file))
+        return 1
+    instructions = read_encoding_table(encoding_file)
+
+    # Filter instructions.
+    names = list(instructions.keys())
+    for name in names:
+        if not os.path.exists(os.path.join(source_dir, "insns", "{}.h".format(name))):
+            del instructions[name]
+
+    output = None
+    if instruction_name:
+        # Look the instruction up.
+        try:
+            instruction = instructions[instruction_name]
+        except KeyError:
+            sys.stderr.write("error: instruction not found in encoding table: '{}'\n".format(instruction_name))
+            return 1
+
+        # Generate code for this instruction.
+        output = generate_from_template(template_body, instruction)
+    else:
+        # Generate code for all instructions.
+        chunks = []
+        for instruction in instructions.values():
+            chunks.append(generate_from_template(template_body, instruction))
+
+            # Sometimes the template sets this CHECK_REG macro and messes up
+            # future generated instructions. This is an issue here as
+            # we generate one big file. This is different to spike's
+            # makefiles, where lots of files are generated. We should consider
+            # moving to that in the future. For now just unset the macros
+            # after each instruction.
+            chunks.append("#undef CHECK_REG")
+            chunks.append("#define CHECK_REG(reg) ((void)0)\n")
+        output = "\n".join(chunks)
+
+    # Write the source file.
+    with open(output_path, "w") as f:
+        if template_header:
+            f.write(template_header + "\n")
+        f.write(output)
+
+    # Write the header file.
+    with open(header_path, "w") as f:
+        for name in sorted(instructions.keys()):
+            f.write("DEFINE_INSN({})\n".format(name))
+
+    return 0
+
+if __name__ == "__main__":
+    sys.exit(main(sys.argv))
diff --git a/riscv/processor.cc b/riscv/processor.cc
index cf3084b8..caad870c 100644
--- a/riscv/processor.cc
+++ b/riscv/processor.cc
@@ -7,6 +7,7 @@
 #include "config.h"
 #include "simif.h"
 #include "mmu.h"
+#include "profiler.h"
 #include "disasm.h"
 #include "platform.h"
 #include <cinttypes>
@@ -50,6 +51,8 @@ processor_t::processor_t(const isa_parser_t *isa, const char* varch,
   for (auto e : isa->get_extensions())
     register_extension(e.second);
 
+  profiler = new profiler_t();
+
   set_pmp_granularity(1 << PMP_SHIFT);
   set_pmp_num(state.max_pmp);
 
@@ -77,6 +80,7 @@ processor_t::~processor_t()
 
   delete mmu;
   delete disassembler;
+  delete profiler;
 }
 
 static void bad_option_string(const char *option, const char *value,
@@ -218,7 +222,8 @@ void state_t::reset(processor_t* const proc, reg_t max_isa)
     const reg_t which_counter = CSR_HPMCOUNTER3 + i - 3;
     const reg_t which_counterh = CSR_HPMCOUNTER3H + i - 3;
     auto mevent = std::make_shared<const_csr_t>(proc, which_mevent, 0);
-    auto mcounter = std::make_shared<const_csr_t>(proc, which_mcounter, 0);
+    auto mcounter = std::make_shared<basic_csr_t>(proc, which_mcounter, 0);
+    auto counter = std::make_shared<counter_proxy_csr_t>(proc, which_counter, mcounter);
     csrmap[which_mevent] = mevent;
     csrmap[which_mcounter] = mcounter;
 
@@ -356,6 +361,8 @@ void state_t::reset(processor_t* const proc, reg_t max_isa)
   csrmap[CSR_TDATA2] = tdata2 = std::make_shared<tdata2_csr_t>(proc, CSR_TDATA2);
   csrmap[CSR_TDATA3] = std::make_shared<const_csr_t>(proc, CSR_TDATA3, 0);
   debug_mode = false;
+  profiler_mode = false;
+  bp_addr = ~0ull;
   single_step = STEP_NONE;
 
   for (int i=0; i < max_pmp; ++i) {
diff --git a/riscv/processor.h b/riscv/processor.h
index 98ff3990..45f13df6 100644
--- a/riscv/processor.h
+++ b/riscv/processor.h
@@ -24,6 +24,7 @@ class simif_t;
 class trap_t;
 class extension_t;
 class disassembler_t;
+class profiler_t;
 
 reg_t illegal_instruction(processor_t* p, insn_t insn, reg_t pc);
 
@@ -174,6 +175,8 @@ struct state_t
   csr_t_p tselect;
   tdata2_csr_t_p tdata2;
   bool debug_mode;
+  bool profiler_mode;
+  reg_t bp_addr;
 
   static const int max_pmp = 16;
   pmpaddr_csr_t_p pmpaddr[max_pmp];
@@ -329,6 +332,7 @@ private:
   mmu_t* mmu; // main memory is always accessed via the mmu
   std::unordered_map<std::string, extension_t*> custom_extensions;
   disassembler_t* disassembler;
+  profiler_t *profiler;
   state_t state;
   uint32_t id;
   unsigned xlen;
diff --git a/riscv/profiler.cc b/riscv/profiler.cc
new file mode 100644
index 00000000..bfbb6416
--- /dev/null
+++ b/riscv/profiler.cc
@@ -0,0 +1,1348 @@
+// See LICENSE for license details.
+
+#include "profiler.h"
+#include "disasm.h"
+#include "processor.h"
+
+constexpr reg_t profiler_t::read_byte_counter;
+constexpr reg_t profiler_t::read_short_counter;
+constexpr reg_t profiler_t::read_word_counter;
+constexpr reg_t profiler_t::read_double_counter;
+constexpr reg_t profiler_t::read_quad_counter;
+constexpr reg_t profiler_t::read_counter;
+constexpr reg_t profiler_t::write_byte_counter;
+constexpr reg_t profiler_t::write_short_counter;
+constexpr reg_t profiler_t::write_word_counter;
+constexpr reg_t profiler_t::write_double_counter;
+constexpr reg_t profiler_t::write_quad_counter;
+constexpr reg_t profiler_t::write_counter;
+constexpr reg_t profiler_t::integer_counter;
+constexpr reg_t profiler_t::float_counter;
+constexpr reg_t profiler_t::branch_counter;
+
+void profiler_memory_op_t::operator()(processor_t &p,
+                                      const unsigned int offset) {
+  auto reg_tc = total_counter + offset;
+  auto reg_lc = length_counter + offset;
+  auto tc = p.get_csr(reg_tc);
+  auto lc = p.get_csr(reg_lc);
+
+  p.put_csr(reg_tc, tc + 1);
+  p.put_csr(reg_lc, lc + 1);
+}
+
+void profiler_logic_op_t::operator()(processor_t &p,
+                                     const unsigned int offset) {
+  auto reg_tc = total_counter + offset;
+  auto tc = p.get_csr(reg_tc);
+
+  p.put_csr(reg_tc, tc + 1);
+}
+
+void profiler_atomic_op_t::operator()(processor_t &p, unsigned int offset) {
+  auto read_op = profiler_memory_op_t(read_total_counter, read_length_counter);
+  auto logic_op = profiler_logic_op_t(logic_total_counter);
+  auto write_op =
+      profiler_memory_op_t(write_total_counter, write_length_counter);
+
+  read_op(p, offset);
+  logic_op(p, offset);
+  write_op(p, offset);
+}
+
+void profiler_t::run(processor_t &p, const insn_t &insn,
+                         const unsigned int xlen) const {
+  auto match = p.get_disassembler()->lookup(insn)->get_match();
+  auto pair = map.find(match);
+  // use offset to select MHPMCOUNTER (0xB03) or MHPMCOUNTERH (0xB83) depending
+  // on xlen
+  auto offset = xlen == 32 ? 80 : 0;
+
+  if (pair == map.end()) {
+    return;
+  }
+
+  pair->second->operator()(p, offset);
+}
+
+profiler_t::profiler_t() {
+  ////////////////////////////////////////////////////////////////////////////
+  // RV32I EXTENSION
+  ////////////////////////////////////////////////////////////////////////////
+
+  // CONTROL TRANSFER INSTRUCTIONS
+  map[MATCH_JAL] =
+      std::make_unique<profiler_logic_op_t>(branch_counter);
+  map[MATCH_JALR] =
+      std::make_unique<profiler_logic_op_t>(branch_counter);
+  map[MATCH_BEQ] =
+      std::make_unique<profiler_logic_op_t>(branch_counter);
+  map[MATCH_BNE] =
+      std::make_unique<profiler_logic_op_t>(branch_counter);
+  map[MATCH_BLT] =
+      std::make_unique<profiler_logic_op_t>(branch_counter);
+  map[MATCH_BGE] =
+      std::make_unique<profiler_logic_op_t>(branch_counter);
+  map[MATCH_BLTU] =
+      std::make_unique<profiler_logic_op_t>(branch_counter);
+  map[MATCH_BGEU] =
+      std::make_unique<profiler_logic_op_t>(branch_counter);
+
+  // LOAD INSTRUCTIONS
+  map[MATCH_LB] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_byte_counter);
+  map[MATCH_LH] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_short_counter);
+  map[MATCH_LW] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_word_counter);
+  map[MATCH_LBU] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_byte_counter);
+  map[MATCH_LHU] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_short_counter);
+
+  // STORE INSTRUCTIONS
+  map[MATCH_SB] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_byte_counter);
+  map[MATCH_SH] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_short_counter);
+  map[MATCH_SW] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_word_counter);
+
+  // LOGIC INSTRUCTIONS
+  map[MATCH_ADDI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_SLTI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_SLTIU] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_XORI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_ORI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_ANDI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_SLLI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_SRLI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_SRAI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_ADD] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_SUB] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_SLL] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_SLT] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_SLTU] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_XOR] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_SRL] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_SRA] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_OR] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_AND] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+
+  ////////////////////////////////////////////////////////////////////////////
+  // RV64I EXTENSION
+  ////////////////////////////////////////////////////////////////////////////
+
+  // LOAD INSTRUCTIONS
+  map[MATCH_LWU] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_word_counter);
+  map[MATCH_LD] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_double_counter);
+
+  // STORE INSTRUCTIONS
+  map[MATCH_SD] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_double_counter);
+
+  // LOGIC INSTRUCTIONS
+  map[MATCH_ADDIW] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_SLLIW] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_SRLIW] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_SRAIW] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_ADDW] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_SUBW] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_SLLW] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_SRLW] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_SRAW] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+
+  ////////////////////////////////////////////////////////////////////////////
+  // M EXTENSION
+  ////////////////////////////////////////////////////////////////////////////
+
+  // LOGIC INSTRUCTIONS
+  map[MATCH_MUL] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_MULH] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_MULHSU] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_MULHU] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_MULW] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_DIV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_DIVU] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_DIVUW] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_DIVW] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_REM] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_REMU] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_REMUW] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_REMW] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+
+  ////////////////////////////////////////////////////////////////////////////
+  // A EXTENSION
+  ////////////////////////////////////////////////////////////////////////////
+
+  // LOAD INSTRUCTIONS
+  map[MATCH_LR_W] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_word_counter);
+  map[MATCH_LR_D] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_double_counter);
+
+  // STORE INSTRUCTIONS
+  map[MATCH_SC_W] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_word_counter);
+  map[MATCH_SC_D] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_double_counter);
+
+  // LOGIC INSTRUCTIONS
+  map[MATCH_AMOSWAP_W] = std::make_unique<profiler_atomic_op_t>(
+      read_counter, read_word_counter,
+      integer_counter, write_counter,
+      write_word_counter);
+  map[MATCH_AMOSWAP_D] = std::make_unique<profiler_atomic_op_t>(
+      read_counter, read_double_counter,
+      integer_counter, write_counter,
+      write_double_counter);
+  map[MATCH_AMOADD_W] = std::make_unique<profiler_atomic_op_t>(
+      read_counter, read_word_counter,
+      integer_counter, write_counter,
+      write_word_counter);
+  map[MATCH_AMOADD_D] = std::make_unique<profiler_atomic_op_t>(
+      read_counter, read_double_counter,
+      integer_counter, write_counter,
+      write_double_counter);
+  map[MATCH_AMOAND_W] = std::make_unique<profiler_atomic_op_t>(
+      read_counter, read_word_counter,
+      integer_counter, write_counter,
+      write_word_counter);
+  map[MATCH_AMOAND_D] = std::make_unique<profiler_atomic_op_t>(
+      read_counter, read_double_counter,
+      integer_counter, write_counter,
+      write_double_counter);
+  map[MATCH_AMOOR_W] = std::make_unique<profiler_atomic_op_t>(
+      read_counter, read_word_counter,
+      integer_counter, write_counter,
+      write_word_counter);
+  map[MATCH_AMOOR_D] = std::make_unique<profiler_atomic_op_t>(
+      read_counter, read_double_counter,
+      integer_counter, write_counter,
+      write_double_counter);
+  map[MATCH_AMOMAX_W] = std::make_unique<profiler_atomic_op_t>(
+      read_counter, read_word_counter,
+      integer_counter, write_counter,
+      write_word_counter);
+  map[MATCH_AMOMAXU_W] = std::make_unique<profiler_atomic_op_t>(
+      read_counter, read_word_counter,
+      integer_counter, write_counter,
+      write_word_counter);
+  map[MATCH_AMOMAX_D] = std::make_unique<profiler_atomic_op_t>(
+      read_counter, read_double_counter,
+      integer_counter, write_counter,
+      write_double_counter);
+  map[MATCH_AMOMAXU_D] = std::make_unique<profiler_atomic_op_t>(
+      read_counter, read_double_counter,
+      integer_counter, write_counter,
+      write_double_counter);
+
+  ////////////////////////////////////////////////////////////////////////////
+  // F EXTENSION
+  ////////////////////////////////////////////////////////////////////////////
+
+  // LOAD INSTRUCTIONS
+  map[MATCH_FLH] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_short_counter);
+  map[MATCH_FLW] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_word_counter);
+
+  // STORE INSTRUCTIONS
+  map[MATCH_FSH] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_short_counter);
+  map[MATCH_FSW] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_word_counter);
+
+  // LOGIC INSTRUCTIONS
+  map[MATCH_FMADD_S] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FMSUB_S] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FNMSUB_S] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FNMADD_S] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FADD_S] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FSUB_S] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FMUL_S] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FDIV_S] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FSQRT_S] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FSGNJ_S] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FSGNJN_S] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FSGNJX_S] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FMIN_S] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FMAX_S] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_W_S] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_WU_S] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FMV_X_S] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FEQ_S] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FLT_S] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FLE_S] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCLASS_S] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_S_W] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_S_WU] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FMV_W_X] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_L_S] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_LU_S] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_S_L] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_S_LU] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+
+  ////////////////////////////////////////////////////////////////////////////
+  // D EXTENSION
+  ////////////////////////////////////////////////////////////////////////////
+
+  // LOAD INSTRUCTIONS
+  map[MATCH_FLD] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_double_counter);
+
+  // STORE INSTRUCTIONS
+  map[MATCH_FSD] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_double_counter);
+
+  // LOGIC INSTRUCTIONS
+  map[MATCH_FMADD_D] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FMSUB_D] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FNMSUB_D] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FNMADD_D] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FADD_D] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FSUB_D] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FMUL_D] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FDIV_D] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FSQRT_D] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FSGNJ_D] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FSGNJN_D] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FSGNJX_D] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FMIN_D] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FMAX_D] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_S_D] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_D_S] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FEQ_D] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FLT_D] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FLE_D] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCLASS_D] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_W_D] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_WU_D] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_D_W] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_D_WU] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+
+  map[MATCH_FCVT_L_D] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_LU_D] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FMV_X_D] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_D_L] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_D_LU] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FMV_D_X] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+
+  ////////////////////////////////////////////////////////////////////////////
+  // Q EXTENSION
+  ////////////////////////////////////////////////////////////////////////////
+
+  // LOAD INSTRUCTIONS
+  map[MATCH_FLQ] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_quad_counter);
+
+  // STORE INSTRUCTIONS
+  map[MATCH_FSQ] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_quad_counter);
+
+  // LOGIC INSTRUCTIONS
+  map[MATCH_FMADD_Q] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FMSUB_Q] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FNMSUB_Q] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FNMADD_Q] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FADD_Q] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FSUB_Q] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FMUL_Q] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FDIV_Q] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FSQRT_Q] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FSGNJ_Q] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FSGNJN_Q] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FSGNJX_Q] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FMIN_Q] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FMAX_Q] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_S_Q] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_Q_S] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FEQ_Q] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FLT_Q] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FLE_Q] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCLASS_Q] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_W_Q] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_WU_Q] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_Q_W] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_Q_WU] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_L_Q] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_LU_Q] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_Q_L] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_FCVT_Q_LU] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+
+  ////////////////////////////////////////////////////////////////////////////
+  // C EXTENSION
+  ////////////////////////////////////////////////////////////////////////////
+
+  // LOAD INSTRUCTIONS
+  map[MATCH_C_LWSP] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_word_counter);
+  map[MATCH_C_LDSP] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_double_counter);
+  map[MATCH_C_FLWSP] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_word_counter);
+  map[MATCH_C_FLDSP] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_double_counter);
+  map[MATCH_C_LW] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_word_counter);
+  map[MATCH_C_LD] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_double_counter);
+  map[MATCH_C_FLW] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_word_counter);
+  map[MATCH_C_FLD] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_double_counter);
+
+  // STORE INSTRUCTIONS
+  map[MATCH_C_SWSP] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_word_counter);
+  map[MATCH_C_SDSP] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_double_counter);
+  map[MATCH_C_FSWSP] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_word_counter);
+  map[MATCH_C_FSDSP] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_double_counter);
+  map[MATCH_C_SW] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_word_counter);
+  map[MATCH_C_SD] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_double_counter);
+  map[MATCH_C_FSW] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_word_counter);
+  map[MATCH_C_FSD] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_double_counter);
+
+  // CONTROL TRANSFER INSTRUCTIONS
+  map[MATCH_C_J] =
+      std::make_unique<profiler_logic_op_t>(branch_counter);
+  map[MATCH_C_JAL] =
+      std::make_unique<profiler_logic_op_t>(branch_counter);
+  map[MATCH_C_JR] =
+      std::make_unique<profiler_logic_op_t>(branch_counter);
+  map[MATCH_C_JALR] =
+      std::make_unique<profiler_logic_op_t>(branch_counter);
+  map[MATCH_C_BEQZ] =
+      std::make_unique<profiler_logic_op_t>(branch_counter);
+  map[MATCH_C_BNEZ] =
+      std::make_unique<profiler_logic_op_t>(branch_counter);
+
+  // LOGIC INSTRUCTIONS
+  map[MATCH_C_LI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_C_LUI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_C_ADDI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_C_ADDIW] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_C_ADDI16SP] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_C_ADDI4SPN] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_C_SLLI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_C_SRLI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_C_SRAI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_C_ANDI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_C_MV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_C_ADD] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_C_AND] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_C_OR] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_C_XOR] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_C_SUB] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_C_ADDW] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_C_SUBW] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+
+  ////////////////////////////////////////////////////////////////////////////
+  // V EXTENSION
+  ////////////////////////////////////////////////////////////////////////////
+
+  // LOAD INSTRUCTIONS
+  // Vector Unit-Stride Instructions
+  map[MATCH_VLE8_V] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_byte_counter);
+  map[MATCH_VLE16_V] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_short_counter);
+  map[MATCH_VLE32_V] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_word_counter);
+  map[MATCH_VLE64_V] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_double_counter);
+  map[MATCH_VLE128_V] =
+      std::make_unique<profiler_logic_op_t>(read_counter);
+  map[MATCH_VLE256_V] =
+      std::make_unique<profiler_logic_op_t>(read_counter);
+  map[MATCH_VLE512_V] =
+      std::make_unique<profiler_logic_op_t>(read_counter);
+  map[MATCH_VLE1024_V] =
+      std::make_unique<profiler_logic_op_t>(read_counter);
+
+  // Vector Strided Instructions
+  map[MATCH_VLSE8_V] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_byte_counter);
+  map[MATCH_VLSE16_V] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_short_counter);
+  map[MATCH_VLSE32_V] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_word_counter);
+  map[MATCH_VLSE64_V] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_double_counter);
+  map[MATCH_VLSE128_V] =
+      std::make_unique<profiler_logic_op_t>(read_counter);
+  map[MATCH_VLSE256_V] =
+      std::make_unique<profiler_logic_op_t>(read_counter);
+  map[MATCH_VLSE512_V] =
+      std::make_unique<profiler_logic_op_t>(read_counter);
+  map[MATCH_VLSE1024_V] =
+      std::make_unique<profiler_logic_op_t>(read_counter);
+
+  // Vector Indexed Instructions
+  map[MATCH_VLUXEI8_V] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_byte_counter);
+  map[MATCH_VLUXEI16_V] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_short_counter);
+  map[MATCH_VLUXEI32_V] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_word_counter);
+  map[MATCH_VLUXEI64_V] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_double_counter);
+  map[MATCH_VLUXEI128_V] =
+      std::make_unique<profiler_logic_op_t>(read_counter);
+  map[MATCH_VLUXEI256_V] =
+      std::make_unique<profiler_logic_op_t>(read_counter);
+  map[MATCH_VLUXEI512_V] =
+      std::make_unique<profiler_logic_op_t>(read_counter);
+  map[MATCH_VLUXEI1024_V] =
+      std::make_unique<profiler_logic_op_t>(read_counter);
+  map[MATCH_VLOXEI8_V] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_byte_counter);
+  map[MATCH_VLOXEI16_V] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_short_counter);
+  map[MATCH_VLOXEI32_V] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_word_counter);
+  map[MATCH_VLOXEI64_V] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_double_counter);
+  map[MATCH_VLOXEI128_V] =
+      std::make_unique<profiler_logic_op_t>(read_counter);
+  map[MATCH_VLOXEI256_V] =
+      std::make_unique<profiler_logic_op_t>(read_counter);
+  map[MATCH_VLOXEI512_V] =
+      std::make_unique<profiler_logic_op_t>(read_counter);
+  map[MATCH_VLOXEI1024_V] =
+      std::make_unique<profiler_logic_op_t>(read_counter);
+
+  //  Unit-stride Fault-Only-First Loads
+  map[MATCH_VLE8FF_V] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_byte_counter);
+  map[MATCH_VLE16FF_V] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_short_counter);
+  map[MATCH_VLE32FF_V] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_word_counter);
+  map[MATCH_VLE64FF_V] = std::make_unique<profiler_memory_op_t>(
+      read_counter, read_double_counter);
+  map[MATCH_VLE128FF_V] =
+      std::make_unique<profiler_logic_op_t>(read_counter);
+  map[MATCH_VLE256FF_V] =
+      std::make_unique<profiler_logic_op_t>(read_counter);
+  map[MATCH_VLE512FF_V] =
+      std::make_unique<profiler_logic_op_t>(read_counter);
+  map[MATCH_VLE1024FF_V] =
+      std::make_unique<profiler_logic_op_t>(read_counter);
+
+  // STORE INSTRUCTIONS
+  // Vector Unit-Stride Instructions
+  map[MATCH_VSE8_V] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_byte_counter);
+  map[MATCH_VSE16_V] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_short_counter);
+  map[MATCH_VSE32_V] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_word_counter);
+  map[MATCH_VSE64_V] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_double_counter);
+  map[MATCH_VSE128_V] =
+      std::make_unique<profiler_logic_op_t>(write_counter);
+  map[MATCH_VSE256_V] =
+      std::make_unique<profiler_logic_op_t>(write_counter);
+  map[MATCH_VSE512_V] =
+      std::make_unique<profiler_logic_op_t>(write_counter);
+  map[MATCH_VSE1024_V] =
+      std::make_unique<profiler_logic_op_t>(write_counter);
+
+  // Vector Strided Instructions
+  map[MATCH_VSSE8_V] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_byte_counter);
+  map[MATCH_VSSE16_V] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_short_counter);
+  map[MATCH_VSSE32_V] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_word_counter);
+  map[MATCH_VSSE64_V] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_double_counter);
+  map[MATCH_VSSE128_V] =
+      std::make_unique<profiler_logic_op_t>(write_counter);
+  map[MATCH_VSSE256_V] =
+      std::make_unique<profiler_logic_op_t>(write_counter);
+  map[MATCH_VSSE512_V] =
+      std::make_unique<profiler_logic_op_t>(write_counter);
+  map[MATCH_VSSE1024_V] =
+      std::make_unique<profiler_logic_op_t>(write_counter);
+
+  // Vector Indexed Instructions
+  map[MATCH_VSUXEI8_V] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_byte_counter);
+  map[MATCH_VSUXEI16_V] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_short_counter);
+  map[MATCH_VSUXEI32_V] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_word_counter);
+  map[MATCH_VSUXEI64_V] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_double_counter);
+  map[MATCH_VSUXEI128_V] =
+      std::make_unique<profiler_logic_op_t>(write_counter);
+  map[MATCH_VSUXEI256_V] =
+      std::make_unique<profiler_logic_op_t>(write_counter);
+  map[MATCH_VSUXEI512_V] =
+      std::make_unique<profiler_logic_op_t>(write_counter);
+  map[MATCH_VSUXEI1024_V] =
+      std::make_unique<profiler_logic_op_t>(write_counter);
+  map[MATCH_VSOXEI8_V] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_byte_counter);
+  map[MATCH_VSOXEI16_V] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_short_counter);
+  map[MATCH_VSOXEI32_V] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_word_counter);
+  map[MATCH_VSOXEI64_V] = std::make_unique<profiler_memory_op_t>(
+      write_counter, write_double_counter);
+  map[MATCH_VSOXEI128_V] =
+      std::make_unique<profiler_logic_op_t>(write_counter);
+  map[MATCH_VSOXEI256_V] =
+      std::make_unique<profiler_logic_op_t>(write_counter);
+  map[MATCH_VSOXEI512_V] =
+      std::make_unique<profiler_logic_op_t>(write_counter);
+  map[MATCH_VSOXEI1024_V] =
+      std::make_unique<profiler_logic_op_t>(write_counter);
+
+  // LOGIC INSTRUCTIONS
+  // Vector Single-Width Integer Add and Subtract
+  map[MATCH_VADD_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VADD_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VADD_VI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSUB_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VRSUB_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VRSUB_VI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+
+  // Vector Widening Integer Add/Subtract
+  map[MATCH_VWADDU_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWADDU_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWSUBU_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWSUBU_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWADD_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWADD_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWSUB_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWSUB_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWADDU_WV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWADDU_WX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWSUBU_WV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWSUBU_WX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWADD_WV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWADD_WX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWSUB_WV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWSUB_WX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+
+  // Vector Integer Extension
+  map[MATCH_VZEXT_VF2] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSEXT_VF2] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VZEXT_VF4] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSEXT_VF4] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VZEXT_VF8] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSEXT_VF8] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+
+  // Vector Integer Add-with-Carry / Subtract-with-Borrow Instructions
+  map[MATCH_VADC_VVM] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VADC_VXM] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VADC_VIM] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMADC_VVM] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMADC_VXM] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMADC_VIM] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSBC_VVM] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSBC_VXM] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMSBC_VVM] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMSBC_VXM] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+
+  // Vector Bitwise Logical Instructions
+  map[MATCH_VADD_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VADD_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VADD_VI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VOR_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VOR_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VOR_VI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VXOR_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VXOR_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VXOR_VI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+
+  // Vector Single-Width Bit Shift Instructions
+  map[MATCH_VSLL_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSLL_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSLL_VI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSRL_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSRL_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSRL_VI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSRA_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSRA_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSRA_VI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+
+  // Vector Narrowing Integer Right Shift Instructions
+  map[MATCH_VNSRL_WV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VNSRL_WX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VNSRL_WI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VNSRA_WV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VNSRA_WX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VNSRA_WI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+
+  // Vector Integer Comparison Instructions
+  map[MATCH_VMSEQ_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMSEQ_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMSEQ_VI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMSNE_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMSNE_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMSNE_VI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMSLTU_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMSLTU_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMSLT_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMSLT_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMSLEU_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMSLEU_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMSLEU_VI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMSLE_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMSLE_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMSLE_VI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMSGTU_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMSGTU_VI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMSGT_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMSGT_VI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+
+  // Vector Integer Min/Max Instructions
+  map[MATCH_VMINU_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMINU_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMIN_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMIN_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMAXU_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMAXU_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMAX_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMAX_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+
+  // Vector Single-Width Integer Multiply Instructions
+  map[MATCH_VMUL_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMUL_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMULH_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMULH_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMULHU_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMULHU_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMULHSU_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMULHSU_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+
+  // Vector Integer Divide Instructions
+  map[MATCH_VDIVU_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VDIVU_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VDIV_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VDIV_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VREMU_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VREMU_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VREM_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VREM_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+
+  // Vector Widening Integer Multiply Instructions
+  map[MATCH_VWMUL_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWMUL_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWMULU_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWMULU_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWMULSU_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWMULSU_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+
+  // Vector Single-Width Integer Multiply-Add Instructions
+  map[MATCH_VMACC_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMACC_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VNMSAC_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VNMSAC_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMADD_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMADD_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VNMSUB_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VNMSUB_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+
+  // Vector Widening Integer Multiply-Add Instructions
+  map[MATCH_VWMACCU_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWMACCU_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWMACC_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWMACC_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWMACCSU_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWMACCSU_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VWMACCUS_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+
+  // Vector Integer Merge Instructions
+  map[MATCH_VMERGE_VVM] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMERGE_VXM] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMERGE_VIM] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+
+  // Vector Integer Move Instructions
+  map[MATCH_VMV_V_V] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMV_V_X] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VMV_V_I] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+
+  // Vector Single-Width Saturating Add and Subtract
+  map[MATCH_VSADDU_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSADDU_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSADDU_VI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSADD_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSADD_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSADD_VI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSSUBU_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSSUBU_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSSUB_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSSUB_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+
+  // Vector Single-Width Averaging Add and Subtract
+  map[MATCH_VAADDU_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VAADDU_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VAADD_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VAADD_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VASUBU_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VASUBU_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VASUB_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VASUB_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+
+  // Vector Single-Width Fractional Multiply with Rounding and Saturation
+  map[MATCH_VSMUL_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSMUL_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+
+  // Vector Single-Width Scaling Shift Instructions
+  map[MATCH_VSSRL_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSSRL_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSSRL_VI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSSRA_VV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSSRA_VX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VSSRA_VI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+
+  // Vector Narrowing Fixed-Point Clip Instructions
+  map[MATCH_VNCLIPU_WV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VNCLIPU_WX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VNCLIPU_WI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VNCLIP_WV] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VNCLIP_WX] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+  map[MATCH_VNCLIP_WI] =
+      std::make_unique<profiler_logic_op_t>(integer_counter);
+
+  // Vector Single-Width Floating-Point Add/Subtract Instructions
+  map[MATCH_VFADD_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFADD_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFSUB_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFSUB_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFRSUB_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+
+  // Vector Widening Floating-Point Add/Subtract Instructions
+  map[MATCH_VFWADD_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFWADD_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFWSUB_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFWSUB_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFWADD_WV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFWADD_WF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFWSUB_WV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFWSUB_WF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+
+  // Vector Single-Width Floating-Point Multiply/Divide Instructions
+  map[MATCH_VFMUL_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFMUL_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFDIV_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFDIV_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFRDIV_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+
+  // Vector Widening Floating-Point Multiply
+  map[MATCH_VFWMUL_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFWMUL_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+
+  // Vector Single-Width Floating-Point Fused Multiply-Add Instructions
+  map[MATCH_VFMACC_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFMACC_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFNMACC_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFNMACC_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFMSAC_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFMSAC_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFNMSAC_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFNMSAC_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFMADD_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFMADD_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFNMADD_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFNMADD_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFMSUB_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFMSUB_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFNMSUB_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFNMSUB_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+
+  // Vector Widening Floating-Point Fused Multiply-Add Instructions
+  map[MATCH_VFWMACC_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFWMACC_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFWNMACC_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFWNMACC_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFWMSAC_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFWMSAC_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFWNMSAC_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFWNMSAC_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+
+  // Vector Floating-Point Square-Root Instruction
+  map[MATCH_VFSQRT_V] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+
+  // Vector Floating-Point Reciprocal Square-Root Estimate Instruction
+  map[MATCH_VFRSQRT7_V] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+
+  // Vector Floating-Point Reciprocal Estimate Instruction
+  map[MATCH_VFREC7_V] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+
+  // Vector Floating-Point MIN/MAX Instructions
+  map[MATCH_VFMIN_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFMIN_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFMAX_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFMAX_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+
+  // Vector Floating-Point Sign-Injection Instructions
+  map[MATCH_VFSGNJ_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFSGNJ_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFSGNJN_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFSGNJN_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFSGNJX_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFSGNJX_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+
+  // Vector Floating-Point Compare Instructions
+  map[MATCH_VMFEQ_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VMFEQ_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VMFNE_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VMFNE_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VMFLT_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VMFLT_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VMFLE_VV] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VMFLE_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VMFGT_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VMFGE_VF] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+
+  // Vector Floating-Point Classify Instruction
+  map[MATCH_VFCLASS_V] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+
+  // Vector Floating-Point Merge Instruction
+  map[MATCH_VFMERGE_VFM] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+
+  // Vector Floating-Point Move Instruction
+  map[MATCH_VFMV_V_F] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+
+  // Single-Width Floating-Point/Integer Type-Convert Instructions
+  map[MATCH_VFCVT_XU_F_V] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFCVT_X_F_V] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFCVT_RTZ_XU_F_V] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFCVT_RTZ_X_F_V] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFCVT_F_XU_V] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFCVT_F_X_V] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+
+  // Widening Floating-Point/Integer Type-Convert Instructions
+  map[MATCH_VFWCVT_XU_F_V] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFWCVT_X_F_V] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFWCVT_RTZ_XU_F_V] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFWCVT_RTZ_X_F_V] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFWCVT_F_XU_V] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFWCVT_F_X_V] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFWCVT_F_F_V] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+
+  // Narrowing Floating-Point/Integer Type-Convert Instructions
+  map[MATCH_VFNCVT_XU_F_W] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFNCVT_X_F_W] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFNCVT_RTZ_XU_F_W] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFNCVT_RTZ_X_F_W] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFNCVT_F_XU_W] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFNCVT_F_X_W] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFNCVT_F_F_W] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+  map[MATCH_VFNCVT_ROD_F_F_W] =
+      std::make_unique<profiler_logic_op_t>(float_counter);
+}
diff --git a/riscv/profiler.h b/riscv/profiler.h
new file mode 100644
index 00000000..98705cf0
--- /dev/null
+++ b/riscv/profiler.h
@@ -0,0 +1,83 @@
+// See LICENSE for license details.
+
+#ifndef _RISCV_PROFILER_H
+#define _RISCV_PROFILER_H
+
+#include "decode.h"
+#include "encoding.h"
+
+#include <memory>
+#include <unordered_map>
+
+class processor_t;
+
+class profiler_abs_t {
+public:
+  virtual ~profiler_abs_t() = default;
+  virtual void operator()(processor_t &, unsigned int) = 0;
+};
+
+class profiler_memory_op_t : public profiler_abs_t {
+public:
+  profiler_memory_op_t(reg_t tc, reg_t lc)
+      : total_counter(tc), length_counter(lc) {}
+  void operator()(processor_t &, unsigned int) override;
+
+private:
+  reg_t total_counter;
+  reg_t length_counter;
+};
+
+class profiler_logic_op_t : public profiler_abs_t {
+public:
+  explicit profiler_logic_op_t(reg_t tc) : total_counter(tc) {}
+  void operator()(processor_t &, unsigned int) override;
+
+private:
+  reg_t total_counter;
+};
+
+class profiler_atomic_op_t : public profiler_abs_t {
+public:
+  explicit profiler_atomic_op_t(reg_t rtc, reg_t rlc, reg_t ltc, reg_t wtc,
+                                reg_t wlc)
+      : read_total_counter(rtc), read_length_counter(rlc),
+        logic_total_counter(ltc), write_total_counter(wtc),
+        write_length_counter(wlc) {}
+  void operator()(processor_t &, unsigned int) override;
+
+private:
+  reg_t read_total_counter;
+  reg_t read_length_counter;
+  reg_t logic_total_counter;
+  reg_t write_total_counter;
+  reg_t write_length_counter;
+};
+
+class profiler_t {
+public:
+  profiler_t();
+
+  void run(processor_t &, const insn_t &, unsigned int) const;
+
+private:
+  std::unordered_map<uint32_t, std::unique_ptr<profiler_abs_t>> map;
+
+  static constexpr reg_t read_byte_counter = CSR_MHPMCOUNTER3;
+  static constexpr reg_t read_short_counter = CSR_MHPMCOUNTER4;
+  static constexpr reg_t read_word_counter = CSR_MHPMCOUNTER5;
+  static constexpr reg_t read_double_counter = CSR_MHPMCOUNTER6;
+  static constexpr reg_t read_quad_counter = CSR_MHPMCOUNTER7;
+  static constexpr reg_t read_counter = CSR_MHPMCOUNTER8;
+  static constexpr reg_t write_byte_counter = CSR_MHPMCOUNTER9;
+  static constexpr reg_t write_short_counter = CSR_MHPMCOUNTER10;
+  static constexpr reg_t write_word_counter = CSR_MHPMCOUNTER11;
+  static constexpr reg_t write_double_counter = CSR_MHPMCOUNTER12;
+  static constexpr reg_t write_quad_counter = CSR_MHPMCOUNTER13;
+  static constexpr reg_t write_counter = CSR_MHPMCOUNTER14;
+  static constexpr reg_t integer_counter = CSR_MHPMCOUNTER15;
+  static constexpr reg_t float_counter = CSR_MHPMCOUNTER16;
+  static constexpr reg_t branch_counter = CSR_MHPMCOUNTER17;
+};
+
+#endif
diff --git a/softfloat/CMakeLists.txt b/softfloat/CMakeLists.txt
new file mode 100644
index 00000000..eb893266
--- /dev/null
+++ b/softfloat/CMakeLists.txt
@@ -0,0 +1,14 @@
+# Copyright (C) Codeplay Software Limited. All Rights Reserved.
+
+FILE(GLOB SOFTLOAT_SRC_FILES ${CMAKE_CURRENT_SOURCE_DIR}/*.c)
+
+add_library(softfloat STATIC ${SOFTLOAT_SRC_FILES})
+
+target_include_directories(softfloat PUBLIC
+    ${CMAKE_CURRENT_SOURCE_DIR}
+)
+
+target_include_directories(softfloat PRIVATE
+    ${SPIKE_BINARY_DIR} # generated headers like config.h and icache.h
+)
+
diff --git a/spike_main/CMakeLists.txt b/spike_main/CMakeLists.txt
new file mode 100644
index 00000000..1ce57171
--- /dev/null
+++ b/spike_main/CMakeLists.txt
@@ -0,0 +1,13 @@
+# Copyright (C) Codeplay Software Limited. All Rights Reserved.
+
+add_executable(spike
+  spike.cc
+)
+
+add_executable(spike-dasm
+  ${CMAKE_CURRENT_SOURCE_DIR}/../spike_dasm/spike-dasm.cc
+)
+
+target_link_libraries(spike riscv-sim fesvr dl)
+
+target_link_libraries(spike-dasm riscv-sim fesvr dl)
