// Copyright (C) Codeplay Software Limited
//
// Licensed under the Apache License, Version 2.0 (the "License") with LLVM
// Exceptions; you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://github.com/codeplaysoftware/oneapi-construction-kit/blob/main/LICENSE.txt
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations
// under the License.
//
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#include <cstdio>
#include <sstream>
#include <string>
#include <thread>
#include <vector>

#include "Common.h"

const char *source =
    "kernel void foo(global int* in_buf, global int* out_buf) {"
    "  int idx = get_global_id(0);"
    "  out_buf[idx] = in_buf[idx];"
    "}";

// Put the above 'source' into source.cl then use the Khronos SPIR generator
// and xxd to convert to a C array.
//
// clang -cc1 -emit-llvm-bc -triple spir-unknown-unknown
//     -include /path/to/opencl_spir.h -O0 -o source.bc32 source.cl
// xxd --include source.bc32
const unsigned char source_bc32[] = {
    0x42, 0x43, 0xc0, 0xde, 0x21, 0x0c, 0x00, 0x00, 0x42, 0x01, 0x00, 0x00,
    0x0b, 0x82, 0x20, 0x00, 0x02, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
    0x07, 0x81, 0x23, 0x91, 0x41, 0xc8, 0x04, 0x49, 0x06, 0x10, 0x32, 0x39,
    0x92, 0x01, 0x84, 0x0c, 0x25, 0x05, 0x08, 0x19, 0x1e, 0x04, 0x8b, 0x62,
    0x80, 0x10, 0x45, 0x02, 0x42, 0x92, 0x0b, 0x42, 0x84, 0x10, 0x32, 0x14,
    0x38, 0x08, 0x18, 0x49, 0x0a, 0x32, 0x44, 0x24, 0x48, 0x0a, 0x90, 0x21,
    0x23, 0xc4, 0x52, 0x80, 0x0c, 0x19, 0x21, 0x72, 0x24, 0x07, 0xc8, 0x08,
    0x11, 0x62, 0xa8, 0xa0, 0xa8, 0x40, 0xc6, 0xf0, 0x01, 0x00, 0x00, 0x00,
    0x49, 0x18, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x0b, 0x84, 0xff, 0xff,
    0xff, 0xff, 0x1f, 0xc0, 0x60, 0x81, 0xf0, 0xff, 0xff, 0xff, 0xff, 0x03,
    0x18, 0x01, 0x00, 0x00, 0x89, 0x20, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00,
    0x32, 0x22, 0x08, 0x09, 0x20, 0x64, 0x85, 0x04, 0x13, 0x22, 0xa4, 0x84,
    0x04, 0x13, 0x22, 0xe3, 0x84, 0xa1, 0x90, 0x14, 0x12, 0x4c, 0x88, 0x8c,
    0x0b, 0x84, 0x84, 0x4c, 0x10, 0x28, 0x23, 0x00, 0x73, 0x04, 0x60, 0x30,
    0x88, 0x10, 0x04, 0x65, 0x00, 0x11, 0x9a, 0x22, 0x44, 0x50, 0x0d, 0x04,
    0x90, 0x50, 0x00, 0x00, 0x13, 0xa8, 0x79, 0x80, 0x87, 0x74, 0x90, 0x87,
    0x36, 0xa8, 0x07, 0x77, 0x58, 0x07, 0x77, 0x78, 0x87, 0x7b, 0x70, 0x87,
    0x36, 0xa8, 0x07, 0x77, 0x58, 0x07, 0x77, 0x78, 0x87, 0x7b, 0x70, 0x87,
    0x0d, 0xae, 0x51, 0x0e, 0x6d, 0x00, 0x0f, 0x7a, 0x30, 0x07, 0x72, 0xa0,
    0x07, 0x73, 0x20, 0x07, 0x7a, 0x30, 0x07, 0x72, 0xd0, 0x06, 0xe9, 0x10,
    0x07, 0x7a, 0x80, 0x07, 0x7a, 0x80, 0x07, 0x6d, 0x90, 0x0e, 0x78, 0xa0,
    0x07, 0x78, 0xa0, 0x07, 0x78, 0xd0, 0x06, 0xe9, 0x10, 0x07, 0x76, 0xa0,
    0x07, 0x71, 0x60, 0x07, 0x7a, 0x10, 0x07, 0x76, 0xd0, 0x06, 0xe9, 0x30,
    0x07, 0x72, 0xa0, 0x07, 0x73, 0x20, 0x07, 0x7a, 0x30, 0x07, 0x72, 0xd0,
    0x06, 0xe9, 0x60, 0x07, 0x74, 0xa0, 0x07, 0x76, 0x40, 0x07, 0x7a, 0x60,
    0x07, 0x74, 0xd0, 0x06, 0xe6, 0x30, 0x07, 0x72, 0xa0, 0x07, 0x73, 0x20,
    0x07, 0x7a, 0x30, 0x07, 0x72, 0xd0, 0x06, 0xe6, 0x60, 0x07, 0x74, 0xa0,
    0x07, 0x76, 0x40, 0x07, 0x7a, 0x60, 0x07, 0x74, 0xd0, 0x06, 0xf6, 0x10,
    0x07, 0x76, 0xa0, 0x07, 0x71, 0x60, 0x07, 0x7a, 0x10, 0x07, 0x76, 0xd0,
    0x06, 0xf6, 0x20, 0x07, 0x74, 0xa0, 0x07, 0x73, 0x20, 0x07, 0x7a, 0x30,
    0x07, 0x72, 0xd0, 0x06, 0xf6, 0x30, 0x07, 0x72, 0xa0, 0x07, 0x73, 0x20,
    0x07, 0x7a, 0x30, 0x07, 0x72, 0xd0, 0x06, 0xf6, 0x40, 0x07, 0x78, 0xa0,
    0x07, 0x76, 0x40, 0x07, 0x7a, 0x60, 0x07, 0x74, 0xd0, 0x06, 0xf6, 0x60,
    0x07, 0x74, 0xa0, 0x07, 0x76, 0x40, 0x07, 0x7a, 0x60, 0x07, 0x74, 0xd0,
    0x06, 0xf6, 0x90, 0x07, 0x76, 0xa0, 0x07, 0x71, 0x20, 0x07, 0x78, 0xa0,
    0x07, 0x71, 0x20, 0x07, 0x78, 0xd0, 0x06, 0xf6, 0x10, 0x07, 0x72, 0x80,
    0x07, 0x7a, 0x10, 0x07, 0x72, 0x80, 0x07, 0x7a, 0x10, 0x07, 0x72, 0x80,
    0x07, 0x6d, 0x60, 0x0f, 0x71, 0x90, 0x07, 0x72, 0xa0, 0x07, 0x72, 0x50,
    0x07, 0x76, 0xa0, 0x07, 0x72, 0x50, 0x07, 0x76, 0xd0, 0x06, 0xf6, 0x20,
    0x07, 0x75, 0x60, 0x07, 0x7a, 0x20, 0x07, 0x75, 0x60, 0x07, 0x7a, 0x20,
    0x07, 0x75, 0x60, 0x07, 0x6d, 0x60, 0x0f, 0x75, 0x10, 0x07, 0x72, 0xa0,
    0x07, 0x75, 0x10, 0x07, 0x72, 0xa0, 0x07, 0x75, 0x10, 0x07, 0x72, 0xd0,
    0x06, 0xf6, 0x10, 0x07, 0x70, 0x20, 0x07, 0x74, 0xa0, 0x07, 0x71, 0x00,
    0x07, 0x72, 0x40, 0x07, 0x7a, 0x10, 0x07, 0x70, 0x20, 0x07, 0x74, 0x30,
    0x44, 0x21, 0x58, 0x01, 0x00, 0x02, 0x00, 0x00, 0x00, 0x60, 0x88, 0x62,
    0xac, 0x42, 0x00, 0x08, 0x00, 0x00, 0x00, 0x40, 0x16, 0x08, 0x00, 0x00,
    0x05, 0x00, 0x00, 0x00, 0x32, 0x1e, 0x98, 0x0c, 0x19, 0x11, 0x4c, 0x90,
    0x8c, 0x09, 0x26, 0x47, 0xc6, 0x04, 0x43, 0x8a, 0x12, 0x28, 0x02, 0x00,
    0x79, 0x18, 0x00, 0x00, 0x7a, 0x00, 0x00, 0x00, 0x43, 0x18, 0x02, 0x38,
    0x82, 0x63, 0x38, 0x8c, 0x23, 0x39, 0x98, 0x21, 0xc6, 0x21, 0x04, 0x42,
    0x20, 0x2c, 0xa8, 0xd6, 0xa1, 0x1c, 0xe4, 0xc1, 0x1d, 0xca, 0x81, 0x1d,
    0x7e, 0x21, 0x1c, 0xe4, 0xe1, 0x1c, 0x7e, 0x21, 0x1c, 0xc8, 0x81, 0x1c,
    0xe4, 0xe1, 0x17, 0xe6, 0x01, 0x1e, 0xc2, 0x61, 0x1c, 0xca, 0x61, 0x88,
    0x71, 0x10, 0x47, 0x71, 0x14, 0x0b, 0xac, 0x75, 0x28, 0x07, 0x79, 0x70,
    0x87, 0x72, 0x60, 0x87, 0x5f, 0x08, 0x07, 0x79, 0x38, 0x87, 0x5f, 0x08,
    0x87, 0x71, 0x18, 0x87, 0x72, 0x98, 0x87, 0x79, 0xf8, 0x85, 0x78, 0xa8,
    0x87, 0x70, 0x60, 0x87, 0x05, 0x84, 0x3b, 0xbc, 0x83, 0x3b, 0x94, 0xc3,
    0x10, 0xe3, 0x38, 0x0e, 0xe4, 0x40, 0x16, 0x3c, 0xeb, 0x50, 0x0e, 0xf2,
    0xe0, 0x0e, 0xe5, 0xc0, 0x0e, 0xbf, 0x10, 0x0e, 0xf2, 0x70, 0x0e, 0xbf,
    0x40, 0x0f, 0xf9, 0x00, 0x0f, 0xe5, 0xb0, 0x80, 0x48, 0x07, 0x77, 0xa0,
    0x07, 0x35, 0x18, 0x62, 0x1c, 0xca, 0xb1, 0x1c, 0xcb, 0x02, 0x6a, 0x1d,
    0xca, 0x41, 0x1e, 0xdc, 0xa1, 0x1c, 0xd8, 0xe1, 0x17, 0xc2, 0x41, 0x1e,
    0xce, 0xe1, 0x17, 0xe8, 0x21, 0x1f, 0xe0, 0xa1, 0x1c, 0x7e, 0x21, 0x1e,
    0xea, 0x21, 0x1c, 0xd8, 0x61, 0x01, 0x30, 0xc4, 0x38, 0x9a, 0x03, 0x39,
    0x90, 0x05, 0xd4, 0x3a, 0x94, 0x83, 0x3c, 0xb8, 0x43, 0x39, 0xb0, 0xc3,
    0x2f, 0x84, 0x83, 0x3c, 0x9c, 0xc3, 0x2f, 0x88, 0x43, 0x38, 0xcc, 0x43,
    0x39, 0xfc, 0x02, 0x3d, 0xe4, 0x03, 0x3c, 0x94, 0xc3, 0x10, 0x22, 0x10,
    0x82, 0x61, 0x08, 0x30, 0xc2, 0x79, 0x07, 0x78, 0x28, 0x07, 0x77, 0x18,
    0x07, 0x76, 0x70, 0x83, 0x75, 0x28, 0x07, 0x79, 0x70, 0x87, 0x72, 0x60,
    0x87, 0x79, 0x98, 0x12, 0x00, 0x23, 0xb2, 0x77, 0x80, 0x87, 0x72, 0x70,
    0x87, 0x71, 0x60, 0x07, 0x37, 0x28, 0x07, 0x77, 0x08, 0x07, 0x71, 0x60,
    0x87, 0x72, 0x70, 0x03, 0x53, 0x80, 0x85, 0x5f, 0x18, 0x85, 0x57, 0x70,
    0x05, 0x5a, 0x90, 0x85, 0x50, 0x18, 0x05, 0x5a, 0x98, 0x02, 0x8c, 0x98,
    0xde, 0x01, 0x1e, 0xca, 0xc1, 0x1d, 0xc6, 0x81, 0x1d, 0xdc, 0x60, 0x1e,
    0xe0, 0x21, 0x1d, 0xe4, 0xc1, 0x0d, 0xec, 0xa1, 0x1c, 0xe4, 0x61, 0x1e,
    0xd2, 0xe1, 0x1d, 0xdc, 0x61, 0x4a, 0xe0, 0x8c, 0x90, 0xde, 0x01, 0x1e,
    0xca, 0xc1, 0x1d, 0xc6, 0x81, 0x1d, 0xdc, 0xe0, 0x1d, 0xc6, 0x81, 0x1d,
    0xdc, 0xc0, 0x1e, 0xca, 0x41, 0x1e, 0xe6, 0x21, 0x1d, 0xde, 0xc1, 0x1d,
    0xa6, 0x04, 0xce, 0x08, 0xeb, 0x1d, 0xe0, 0xa1, 0x1c, 0xdc, 0x61, 0x1c,
    0xd8, 0xc1, 0x0d, 0xea, 0x61, 0x1e, 0xca, 0x81, 0x1c, 0xdc, 0xa0, 0x1c,
    0xf0, 0x81, 0x1e, 0xca, 0xc1, 0x1d, 0xe6, 0x21, 0x1d, 0xde, 0xc1, 0x1d,
    0xe6, 0x61, 0x4a, 0xf0, 0x8c, 0x10, 0x83, 0x77, 0x80, 0x87, 0x72, 0x70,
    0x87, 0x71, 0x60, 0x07, 0x37, 0xa8, 0x87, 0x79, 0x28, 0x07, 0x72, 0x70,
    0x83, 0x77, 0x80, 0x07, 0x7a, 0x48, 0x87, 0x77, 0x70, 0x87, 0x70, 0x60,
    0x07, 0x37, 0x18, 0x87, 0x77, 0x90, 0x87, 0x72, 0x70, 0x03, 0x73, 0x28,
    0x87, 0x70, 0xa0, 0x87, 0x7a, 0x90, 0x87, 0x72, 0x98, 0x87, 0x29, 0xc1,
    0x33, 0xe2, 0x7a, 0x07, 0x78, 0x28, 0x07, 0x77, 0x18, 0x07, 0x76, 0x70,
    0x83, 0x71, 0x78, 0x87, 0x76, 0x80, 0x87, 0x74, 0x60, 0x87, 0x72, 0x90,
    0x07, 0x37, 0x78, 0x07, 0x78, 0xa0, 0x87, 0x74, 0x78, 0x07, 0x77, 0x98,
    0x87, 0x29, 0xc1, 0x03, 0x79, 0x18, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00,
    0x33, 0x08, 0x80, 0x1c, 0xc4, 0xe1, 0x1c, 0x66, 0x14, 0x01, 0x3d, 0x88,
    0x43, 0x38, 0x84, 0xc3, 0x8c, 0x42, 0x80, 0x07, 0x79, 0x78, 0x07, 0x73,
    0x98, 0x71, 0x0c, 0xe6, 0x00, 0x0f, 0xed, 0x10, 0x0e, 0xf4, 0x80, 0x0e,
    0x33, 0x0c, 0x42, 0x1e, 0xc2, 0xc1, 0x1d, 0xce, 0xa1, 0x1c, 0x66, 0x30,
    0x05, 0x3d, 0x88, 0x43, 0x38, 0x84, 0x83, 0x1b, 0xcc, 0x03, 0x3d, 0xc8,
    0x43, 0x3d, 0x8c, 0x03, 0x3d, 0x00, 0x00, 0x00, 0x71, 0x20, 0x00, 0x00,
    0x06, 0x00, 0x00, 0x00, 0x16, 0x20, 0xfd, 0x73, 0x7d, 0x1b, 0xc4, 0xf4,
    0x1b, 0x8b, 0x13, 0x00, 0xcb, 0x8f, 0x0c, 0x89, 0x01, 0x0c, 0x85, 0xe3,
    0x00, 0x00, 0x00, 0x00, 0x61, 0x20, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00,
    0x13, 0x04, 0x41, 0x2c, 0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x14, 0x23, 0x00, 0x00, 0x33, 0x11, 0x48, 0x20, 0x0c, 0x33, 0x11, 0x48,
    0x20, 0x0c, 0x33, 0x11, 0x49, 0x20, 0x0c, 0x83, 0x11, 0x83, 0x31, 0x00,
    0x83, 0x11, 0x42, 0x31, 0x00, 0x23, 0x06, 0x84, 0x60, 0x13, 0x09, 0x31,
    0x18, 0x21, 0x04, 0x03, 0x40, 0xc2, 0xa0, 0x62, 0x8c, 0x27, 0x04, 0x02,
    0x05, 0x83, 0x8c, 0x41, 0xc8, 0x18, 0x4f, 0x08, 0x84, 0xc1, 0x88, 0x80,
    0x18, 0x00, 0x0c, 0x07, 0x02, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
    0x46, 0x60, 0x20, 0xcd, 0x1f, 0x50, 0x85, 0x15, 0x1c, 0x0e, 0x35, 0xfd,
    0x01, 0x55, 0x58, 0xc2, 0x80, 0x0c, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00};
const size_t source_bc32_len = 1300;

// clang -cc1 -emit-llvm-bc -triple spir64-unknown-unknown
//     -include /path/to/opencl_spir.h -O0 -o source.bc64 source.cl
// xxd --include source.bc64
const unsigned char source_bc64[] = {
    0x42, 0x43, 0xc0, 0xde, 0x21, 0x0c, 0x00, 0x00, 0x45, 0x01, 0x00, 0x00,
    0x0b, 0x82, 0x20, 0x00, 0x02, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
    0x07, 0x81, 0x23, 0x91, 0x41, 0xc8, 0x04, 0x49, 0x06, 0x10, 0x32, 0x39,
    0x92, 0x01, 0x84, 0x0c, 0x25, 0x05, 0x08, 0x19, 0x1e, 0x04, 0x8b, 0x62,
    0x80, 0x10, 0x45, 0x02, 0x42, 0x92, 0x0b, 0x42, 0x84, 0x10, 0x32, 0x14,
    0x38, 0x08, 0x18, 0x49, 0x0a, 0x32, 0x44, 0x24, 0x48, 0x0a, 0x90, 0x21,
    0x23, 0xc4, 0x52, 0x80, 0x0c, 0x19, 0x21, 0x72, 0x24, 0x07, 0xc8, 0x08,
    0x11, 0x62, 0xa8, 0xa0, 0xa8, 0x40, 0xc6, 0xf0, 0x01, 0x00, 0x00, 0x00,
    0x49, 0x18, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x0b, 0x84, 0xff, 0xff,
    0xff, 0xff, 0x1f, 0xc0, 0x60, 0x81, 0xf0, 0xff, 0xff, 0xff, 0xff, 0x03,
    0x18, 0x01, 0x00, 0x00, 0x89, 0x20, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00,
    0x32, 0x22, 0x08, 0x09, 0x20, 0x64, 0x85, 0x04, 0x13, 0x22, 0xa4, 0x84,
    0x04, 0x13, 0x22, 0xe3, 0x84, 0xa1, 0x90, 0x14, 0x12, 0x4c, 0x88, 0x8c,
    0x0b, 0x84, 0x84, 0x4c, 0x10, 0x2c, 0x23, 0x00, 0x73, 0x04, 0x60, 0x30,
    0x88, 0x10, 0x04, 0x65, 0x00, 0x11, 0x9a, 0x39, 0x02, 0x50, 0x28, 0x42,
    0x05, 0xd9, 0x40, 0x00, 0x09, 0x05, 0x00, 0x00, 0x13, 0xac, 0x79, 0x80,
    0x87, 0x74, 0x90, 0x07, 0x3b, 0xa0, 0x83, 0x36, 0xa8, 0x07, 0x77, 0x58,
    0x07, 0x77, 0x78, 0x87, 0x7b, 0x70, 0x87, 0x36, 0xa8, 0x07, 0x77, 0x58,
    0x07, 0x77, 0x78, 0x87, 0x7b, 0x70, 0x87, 0x0d, 0xae, 0x51, 0x0e, 0x6d,
    0x00, 0x0f, 0x7a, 0x60, 0x07, 0x74, 0xa0, 0x07, 0x76, 0x40, 0x07, 0x7a,
    0x60, 0x07, 0x74, 0xd0, 0x06, 0xe9, 0x10, 0x07, 0x7a, 0x80, 0x07, 0x7a,
    0x80, 0x07, 0x6d, 0x90, 0x0e, 0x78, 0xa0, 0x07, 0x78, 0xa0, 0x07, 0x78,
    0xd0, 0x06, 0xe9, 0x10, 0x07, 0x76, 0xa0, 0x07, 0x71, 0x60, 0x07, 0x7a,
    0x10, 0x07, 0x76, 0xd0, 0x06, 0xe9, 0x30, 0x07, 0x72, 0xa0, 0x07, 0x73,
    0x20, 0x07, 0x7a, 0x30, 0x07, 0x72, 0xd0, 0x06, 0xe9, 0x60, 0x07, 0x74,
    0xa0, 0x07, 0x76, 0x40, 0x07, 0x7a, 0x60, 0x07, 0x74, 0xd0, 0x06, 0xe6,
    0x30, 0x07, 0x72, 0xa0, 0x07, 0x73, 0x20, 0x07, 0x7a, 0x30, 0x07, 0x72,
    0xd0, 0x06, 0xe6, 0x60, 0x07, 0x74, 0xa0, 0x07, 0x76, 0x40, 0x07, 0x7a,
    0x60, 0x07, 0x74, 0xd0, 0x06, 0xf6, 0x10, 0x07, 0x76, 0xa0, 0x07, 0x71,
    0x60, 0x07, 0x7a, 0x10, 0x07, 0x76, 0xd0, 0x06, 0xf6, 0x20, 0x07, 0x74,
    0xa0, 0x07, 0x73, 0x20, 0x07, 0x7a, 0x30, 0x07, 0x72, 0xd0, 0x06, 0xf6,
    0x30, 0x07, 0x72, 0xa0, 0x07, 0x73, 0x20, 0x07, 0x7a, 0x30, 0x07, 0x72,
    0xd0, 0x06, 0xf6, 0x40, 0x07, 0x78, 0xa0, 0x07, 0x76, 0x40, 0x07, 0x7a,
    0x60, 0x07, 0x74, 0xd0, 0x06, 0xf6, 0x60, 0x07, 0x74, 0xa0, 0x07, 0x76,
    0x40, 0x07, 0x7a, 0x60, 0x07, 0x74, 0xd0, 0x06, 0xf6, 0x90, 0x07, 0x76,
    0xa0, 0x07, 0x71, 0x20, 0x07, 0x78, 0xa0, 0x07, 0x71, 0x20, 0x07, 0x78,
    0xd0, 0x06, 0xf6, 0x10, 0x07, 0x72, 0x80, 0x07, 0x7a, 0x10, 0x07, 0x72,
    0x80, 0x07, 0x7a, 0x10, 0x07, 0x72, 0x80, 0x07, 0x6d, 0x60, 0x0f, 0x71,
    0x90, 0x07, 0x72, 0xa0, 0x07, 0x72, 0x50, 0x07, 0x76, 0xa0, 0x07, 0x72,
    0x50, 0x07, 0x76, 0xd0, 0x06, 0xf6, 0x20, 0x07, 0x75, 0x60, 0x07, 0x7a,
    0x20, 0x07, 0x75, 0x60, 0x07, 0x7a, 0x20, 0x07, 0x75, 0x60, 0x07, 0x6d,
    0x60, 0x0f, 0x75, 0x10, 0x07, 0x72, 0xa0, 0x07, 0x75, 0x10, 0x07, 0x72,
    0xa0, 0x07, 0x75, 0x10, 0x07, 0x72, 0xd0, 0x06, 0xf6, 0x10, 0x07, 0x70,
    0x20, 0x07, 0x74, 0xa0, 0x07, 0x71, 0x00, 0x07, 0x72, 0x40, 0x07, 0x7a,
    0x10, 0x07, 0x70, 0x20, 0x07, 0x74, 0x30, 0x44, 0x21, 0x58, 0x01, 0x00,
    0x02, 0x00, 0x00, 0x00, 0x60, 0x88, 0x72, 0xac, 0x42, 0x00, 0x08, 0x00,
    0x00, 0x00, 0x40, 0x16, 0x08, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
    0x32, 0x1e, 0x98, 0x0c, 0x19, 0x11, 0x4c, 0x90, 0x8c, 0x09, 0x26, 0x47,
    0xc6, 0x04, 0x43, 0x8a, 0x12, 0x28, 0x02, 0x00, 0x79, 0x18, 0x00, 0x00,
    0x7a, 0x00, 0x00, 0x00, 0x43, 0x18, 0x02, 0x40, 0x02, 0x64, 0x40, 0x0c,
    0x24, 0x41, 0x98, 0x21, 0x06, 0x22, 0x04, 0x42, 0x20, 0x2c, 0xa8, 0xd6,
    0xa1, 0x1c, 0xe4, 0xc1, 0x1d, 0xca, 0x81, 0x1d, 0x7e, 0x21, 0x1c, 0xe4,
    0xe1, 0x1c, 0x7e, 0x21, 0x1c, 0xc8, 0x81, 0x1c, 0xe4, 0xe1, 0x17, 0xe6,
    0x01, 0x1e, 0xc2, 0x61, 0x1c, 0xca, 0x61, 0x88, 0x81, 0x10, 0x48, 0x81,
    0x14, 0x0b, 0xac, 0x75, 0x28, 0x07, 0x79, 0x70, 0x87, 0x72, 0x60, 0x87,
    0x5f, 0x08, 0x07, 0x79, 0x38, 0x87, 0x5f, 0x08, 0x87, 0x71, 0x18, 0x87,
    0x72, 0x98, 0x87, 0x79, 0xf8, 0x85, 0x78, 0xa8, 0x87, 0x70, 0x60, 0x87,
    0x05, 0x84, 0x3b, 0xbc, 0x83, 0x3b, 0x94, 0xc3, 0x10, 0x03, 0x39, 0x10,
    0x04, 0x41, 0x16, 0x3c, 0xeb, 0x50, 0x0e, 0xf2, 0xe0, 0x0e, 0xe5, 0xc0,
    0x0e, 0xbf, 0x10, 0x0e, 0xf2, 0x70, 0x0e, 0xbf, 0x40, 0x0f, 0xf9, 0x00,
    0x0f, 0xe5, 0xb0, 0x80, 0x48, 0x07, 0x77, 0xa0, 0x07, 0x35, 0x18, 0x62,
    0x20, 0x0a, 0xb2, 0x20, 0xcb, 0x02, 0x6a, 0x1d, 0xca, 0x41, 0x1e, 0xdc,
    0xa1, 0x1c, 0xd8, 0xe1, 0x17, 0xc2, 0x41, 0x1e, 0xce, 0xe1, 0x17, 0xe8,
    0x21, 0x1f, 0xe0, 0xa1, 0x1c, 0x7e, 0x21, 0x1e, 0xea, 0x21, 0x1c, 0xd8,
    0x61, 0x01, 0x30, 0xc4, 0x40, 0x1a, 0x04, 0x41, 0x90, 0x05, 0xd4, 0x3a,
    0x94, 0x83, 0x3c, 0xb8, 0x43, 0x39, 0xb0, 0xc3, 0x2f, 0x84, 0x83, 0x3c,
    0x9c, 0xc3, 0x2f, 0x88, 0x43, 0x38, 0xcc, 0x43, 0x39, 0xfc, 0x02, 0x3d,
    0xe4, 0x03, 0x3c, 0x94, 0xc3, 0x10, 0x22, 0x10, 0x82, 0x61, 0x08, 0x30,
    0xc2, 0x79, 0x07, 0x78, 0x28, 0x07, 0x77, 0x18, 0x07, 0x76, 0x70, 0x83,
    0x75, 0x28, 0x07, 0x79, 0x70, 0x87, 0x72, 0x60, 0x87, 0x79, 0x98, 0x12,
    0x00, 0x23, 0xb2, 0x77, 0x80, 0x87, 0x72, 0x70, 0x87, 0x71, 0x60, 0x07,
    0x37, 0x28, 0x07, 0x77, 0x08, 0x07, 0x71, 0x60, 0x87, 0x72, 0x70, 0x03,
    0x53, 0x80, 0x85, 0x5f, 0x18, 0x85, 0x57, 0x70, 0x05, 0x5a, 0x90, 0x85,
    0x50, 0x18, 0x05, 0x5a, 0x98, 0x02, 0x8c, 0x98, 0xde, 0x01, 0x1e, 0xca,
    0xc1, 0x1d, 0xc6, 0x81, 0x1d, 0xdc, 0x60, 0x1e, 0xe0, 0x21, 0x1d, 0xe4,
    0xc1, 0x0d, 0xec, 0xa1, 0x1c, 0xe4, 0x61, 0x1e, 0xd2, 0xe1, 0x1d, 0xdc,
    0x61, 0x4a, 0xe0, 0x8c, 0x90, 0xde, 0x01, 0x1e, 0xca, 0xc1, 0x1d, 0xc6,
    0x81, 0x1d, 0xdc, 0xe0, 0x1d, 0xc6, 0x81, 0x1d, 0xdc, 0xc0, 0x1e, 0xca,
    0x41, 0x1e, 0xe6, 0x21, 0x1d, 0xde, 0xc1, 0x1d, 0xa6, 0x04, 0xce, 0x08,
    0xeb, 0x1d, 0xe0, 0xa1, 0x1c, 0xdc, 0x61, 0x1c, 0xd8, 0xc1, 0x0d, 0xea,
    0x61, 0x1e, 0xca, 0x81, 0x1c, 0xdc, 0xa0, 0x1c, 0xf0, 0x81, 0x1e, 0xca,
    0xc1, 0x1d, 0xe6, 0x21, 0x1d, 0xde, 0xc1, 0x1d, 0xe6, 0x61, 0x4a, 0xf0,
    0x8c, 0x10, 0x83, 0x77, 0x80, 0x87, 0x72, 0x70, 0x87, 0x71, 0x60, 0x07,
    0x37, 0xa8, 0x87, 0x79, 0x28, 0x07, 0x72, 0x70, 0x83, 0x77, 0x80, 0x07,
    0x7a, 0x48, 0x87, 0x77, 0x70, 0x87, 0x70, 0x60, 0x07, 0x37, 0x18, 0x87,
    0x77, 0x90, 0x87, 0x72, 0x70, 0x03, 0x73, 0x28, 0x87, 0x70, 0xa0, 0x87,
    0x7a, 0x90, 0x87, 0x72, 0x98, 0x87, 0x29, 0xc1, 0x33, 0xe2, 0x7a, 0x07,
    0x78, 0x28, 0x07, 0x77, 0x18, 0x07, 0x76, 0x70, 0x83, 0x71, 0x78, 0x87,
    0x76, 0x80, 0x87, 0x74, 0x60, 0x87, 0x72, 0x90, 0x07, 0x37, 0x78, 0x07,
    0x78, 0xa0, 0x87, 0x74, 0x78, 0x07, 0x77, 0x98, 0x87, 0x29, 0xc1, 0x03,
    0x79, 0x18, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x33, 0x08, 0x80, 0x1c,
    0xc4, 0xe1, 0x1c, 0x66, 0x14, 0x01, 0x3d, 0x88, 0x43, 0x38, 0x84, 0xc3,
    0x8c, 0x42, 0x80, 0x07, 0x79, 0x78, 0x07, 0x73, 0x98, 0x71, 0x0c, 0xe6,
    0x00, 0x0f, 0xed, 0x10, 0x0e, 0xf4, 0x80, 0x0e, 0x33, 0x0c, 0x42, 0x1e,
    0xc2, 0xc1, 0x1d, 0xce, 0xa1, 0x1c, 0x66, 0x30, 0x05, 0x3d, 0x88, 0x43,
    0x38, 0x84, 0x83, 0x1b, 0xcc, 0x03, 0x3d, 0xc8, 0x43, 0x3d, 0x8c, 0x03,
    0x3d, 0x00, 0x00, 0x00, 0x71, 0x20, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
    0x16, 0x20, 0xfd, 0x73, 0x7d, 0x1b, 0xc4, 0xf4, 0x1b, 0x8b, 0x13, 0x00,
    0xcb, 0x8f, 0x0c, 0x89, 0x01, 0x0c, 0x85, 0xe3, 0x00, 0x00, 0x00, 0x00,
    0x61, 0x20, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x13, 0x04, 0x41, 0x2c,
    0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x14, 0x23, 0x00, 0x00,
    0x33, 0x11, 0x49, 0x20, 0x10, 0x33, 0x11, 0x49, 0x20, 0x10, 0x33, 0x11,
    0x4a, 0x20, 0x0c, 0x83, 0x11, 0x83, 0x41, 0x00, 0x83, 0x11, 0x42, 0x41,
    0x00, 0x23, 0x06, 0x84, 0x60, 0x13, 0x09, 0x71, 0x41, 0xc0, 0x60, 0xc4,
    0x10, 0x0c, 0x00, 0x0d, 0xe3, 0x82, 0x12, 0x3a, 0xc8, 0x78, 0x42, 0x20,
    0x50, 0x30, 0x08, 0x19, 0x17, 0x94, 0xd0, 0x42, 0xc6, 0x13, 0x02, 0x61,
    0x30, 0x22, 0x28, 0x06, 0x00, 0xc3, 0x81, 0x00, 0x05, 0x00, 0x00, 0x00,
    0x46, 0x60, 0x20, 0xcd, 0x1f, 0x50, 0x85, 0x15, 0x1c, 0x0e, 0x35, 0xfd,
    0x01, 0x55, 0x58, 0xc2, 0x80, 0x0c, 0x17, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00};
const size_t source_bc64_len = 1312;

class clCreateProgramWithBinaryTest : public ucl::ContextTest {
 protected:
  void SetUp() {
    UCL_RETURN_ON_FATAL_FAILURE(ContextTest::SetUp());
#ifndef CA_CL_ENABLE_OFFLINE_KERNEL_TESTS
    // This test requires offline kernels
    GTEST_SKIP();
#endif
    auto bin_src = getDeviceBinaryFromFile("clCreateProgramWithBinaryTest");
    const unsigned char *src_data = bin_src.data();
    const size_t src_size = bin_src.size();
    cl_int errcode;
    const cl_program originalProgram = clCreateProgramWithBinary(
        context, 1, &device, &src_size, &src_data, nullptr, &errcode);

    // Size in bytes
    size_t binaryLengthsSize = 1 * sizeof(size_t);
    binaryLengths.resize(1);
    ASSERT_SUCCESS(clGetProgramInfo(originalProgram, CL_PROGRAM_BINARY_SIZES,
                                    binaryLengthsSize, binaryLengths.data(),
                                    nullptr));
    binaries = new const unsigned char *[1];
    for (unsigned i = 0; i < 1; ++i) {
      binaries[i] = new unsigned char[binaryLengths[i]];
    }
    ASSERT_SUCCESS(clGetProgramInfo(originalProgram, CL_PROGRAM_BINARIES,
                                    binaryLengthsSize, binaries, nullptr));
    binaryStatii.resize(1);
    ASSERT_SUCCESS(clReleaseProgram(originalProgram));
  }

  void TearDown() {
    if (nullptr != binaries) {
      for (unsigned i = 0; i < 1; ++i) {
        delete[] binaries[i];
      }
      delete[] binaries;
    }
    if (program) {
      EXPECT_SUCCESS(clReleaseProgram(program));
    }
    ContextTest::TearDown();
  }

  UCL::vector<size_t> binaryLengths;
  const unsigned char **binaries = {};
  UCL::vector<cl_int> binaryStatii;
  cl_program program = nullptr;
};

TEST_F(clCreateProgramWithBinaryTest, InvalidContext) {
  cl_int errcode = !CL_SUCCESS;
  program = clCreateProgramWithBinary(nullptr, 1, &device, binaryLengths.data(),
                                      binaries, binaryStatii.data(), &errcode);
  EXPECT_FALSE(program);
  ASSERT_EQ_ERRCODE(CL_INVALID_CONTEXT, errcode);
}

TEST_F(clCreateProgramWithBinaryTest, InvalidValueDevice) {
  cl_int errcode = !CL_SUCCESS;
  program = clCreateProgramWithBinary(context, 0, &device, binaryLengths.data(),
                                      binaries, binaryStatii.data(), &errcode);
  EXPECT_FALSE(program);
  ASSERT_EQ_ERRCODE(CL_INVALID_VALUE, errcode);
  program = clCreateProgramWithBinary(context, 1, nullptr, binaryLengths.data(),
                                      binaries, binaryStatii.data(), &errcode);
  EXPECT_FALSE(program);
  ASSERT_EQ_ERRCODE(CL_INVALID_VALUE, errcode);
}

TEST_F(clCreateProgramWithBinaryTest, InvalidValueLengths) {
  cl_int errcode = !CL_SUCCESS;
  program = clCreateProgramWithBinary(context, 1, &device, nullptr, binaries,
                                      binaryStatii.data(), &errcode);
  EXPECT_FALSE(program);
  ASSERT_EQ_ERRCODE(CL_INVALID_VALUE, errcode);
  program = clCreateProgramWithBinary(context, 1, &device, binaryLengths.data(),
                                      nullptr, binaryStatii.data(), &errcode);
  EXPECT_FALSE(program);
  ASSERT_EQ_ERRCODE(CL_INVALID_VALUE, errcode);
}

// Redmine #5134: Test invalid value of null length and binary values in lists,
// requires multiple devices

/* Redmine #5134: Test for invalid devices, this requires targeting multiple
 * devices at once.
TEST_F(clCreateProgramWithBinaryTest, InvalidDevice)
{
}
*/

TEST_F(clCreateProgramWithBinaryTest, InvalidBinary) {
  cl_int errcode = !CL_SUCCESS;
  const unsigned char **invalidbinaries =
      reinterpret_cast<const unsigned char **>(
          new char[sizeof(unsigned char *) * 1]);
  size_t invalidBinLen = 64;
  for (unsigned i = 0; i < 1; ++i) {
    invalidbinaries[i] = new unsigned char[invalidBinLen];
    memset(const_cast<unsigned char **>(invalidbinaries)[i], 1, invalidBinLen);
  }
  program =
      clCreateProgramWithBinary(context, 1, &device, binaryLengths.data(),
                                invalidbinaries, binaryStatii.data(), &errcode);
  EXPECT_FALSE(program);
  EXPECT_EQ_ERRCODE(CL_INVALID_BINARY, errcode);
  for (unsigned i = 0; i < 1; ++i) {
    EXPECT_EQ_ERRCODE(CL_INVALID_BINARY, binaryStatii[i]);
    delete[] invalidbinaries[i];
  }
  delete[] invalidbinaries;
}

TEST_F(clCreateProgramWithBinaryTest, InvalidValueBinaryStatus) {
  cl_int errcode = !CL_SUCCESS;
  for (unsigned i = 0; i < 1; ++i) {
    binaryLengths[i] = 0;
  }
  program = clCreateProgramWithBinary(context, 1, &device, binaryLengths.data(),
                                      binaries, binaryStatii.data(), &errcode);
  EXPECT_FALSE(program);
  ASSERT_EQ_ERRCODE(CL_INVALID_VALUE, errcode);
  for (unsigned i = 0; i < 1; ++i) {
    ASSERT_EQ_ERRCODE(CL_INVALID_VALUE, binaryStatii[i]);
  }
}

/*! Redmine #5134: Test for additional binary_status values */

TEST_F(clCreateProgramWithBinaryTest, Default) {
  cl_int errcode = !CL_SUCCESS;
  program = clCreateProgramWithBinary(context, 1, &device, binaryLengths.data(),
                                      binaries, binaryStatii.data(), &errcode);
  EXPECT_TRUE(program);
  ASSERT_SUCCESS(errcode);
  for (unsigned i = 0; i < 1; ++i) {
    ASSERT_SUCCESS(binaryStatii[i]);
  }
}

TEST_F(clCreateProgramWithBinaryTest, GetBinaryType) {
  cl_int errcode = !CL_SUCCESS;
  program = clCreateProgramWithBinary(context, 1, &device, binaryLengths.data(),
                                      binaries, binaryStatii.data(), &errcode);
  EXPECT_TRUE(program);
  ASSERT_SUCCESS(errcode);

  cl_program_binary_type binary_type;
  ASSERT_SUCCESS(clGetProgramBuildInfo(program, device, CL_PROGRAM_BINARY_TYPE,
                                       sizeof(binary_type), &binary_type,
                                       nullptr));

  ASSERT_EQ(CL_PROGRAM_BINARY_TYPE_EXECUTABLE, binary_type);
}

TEST_F(clCreateProgramWithBinaryTest, DefaultNDRangeKernelWithoutBuild) {
  cl_int errcode = !CL_SUCCESS;
  program = clCreateProgramWithBinary(context, 1, &device, binaryLengths.data(),
                                      binaries, binaryStatii.data(), &errcode);
  EXPECT_TRUE(program);
  ASSERT_SUCCESS(errcode);

  // clBuildProgram() is permitted, but not required, when the binary is an
  // executable. See also `CreateProgramThenTryBuild`.
  cl_kernel kernel = clCreateKernel(program, "foo", &errcode);
  EXPECT_TRUE(kernel);
  ASSERT_SUCCESS(errcode);
  ASSERT_SUCCESS(clReleaseKernel(kernel));
}

// The same as DefaultNDRangeKernelWithoutBuild, but with SPIR
TEST_F(clCreateProgramWithBinaryTest, DefaultNDRangeSpirKernelWithoutBuild) {
  if (!UCL::hasCompilerSupport(device)) {
    GTEST_SKIP();
  }

  cl_uint bits;
  cl_int errcode = clGetDeviceInfo(device, CL_DEVICE_ADDRESS_BITS,
                                   sizeof(cl_uint), &bits, nullptr);
  ASSERT_SUCCESS(errcode);
  ASSERT_TRUE((bits == 32) || (bits == 64));

  size_t len = (bits == 32) ? source_bc32_len : source_bc64_len;
  const unsigned char *data = (bits == 32) ? source_bc32 : source_bc64;

  program = clCreateProgramWithBinary(context, 1, &device, &len, &data,
                                      binaryStatii.data(), &errcode);
  EXPECT_TRUE(program);
  ASSERT_SUCCESS(errcode);

  // clBuildProgram() **must** be called when the binary is SPIR. Otherwise,
  // the kernel cannot be created.
  cl_kernel kernel = clCreateKernel(program, "foo", &errcode);
  EXPECT_FALSE(kernel);
  ASSERT_EQ_ERRCODE(CL_INVALID_PROGRAM_EXECUTABLE, errcode);
}

TEST_F(clCreateProgramWithBinaryTest, DefaultNDRangeKernel) {
  cl_int errcode = !CL_SUCCESS;
  program = clCreateProgramWithBinary(context, 1, &device, binaryLengths.data(),
                                      binaries, binaryStatii.data(), &errcode);
  EXPECT_TRUE(program);
  ASSERT_SUCCESS(errcode);

  size_t elements = 64;
  size_t buflen = elements * sizeof(cl_int);

  cl_mem bufin =
      clCreateBuffer(context, CL_MEM_READ_ONLY, buflen, nullptr, &errcode);
  EXPECT_TRUE(bufin);
  ASSERT_SUCCESS(errcode);

  cl_mem bufout =
      clCreateBuffer(context, CL_MEM_WRITE_ONLY, buflen, nullptr, &errcode);
  EXPECT_TRUE(bufout);
  ASSERT_SUCCESS(errcode);

  cl_kernel kernel = clCreateKernel(program, "foo", &errcode);
  EXPECT_TRUE(kernel);
  ASSERT_SUCCESS(errcode);

  ASSERT_SUCCESS(clSetKernelArg(kernel, 0, sizeof(cl_mem), &bufin));
  ASSERT_SUCCESS(clSetKernelArg(kernel, 1, sizeof(cl_mem), &bufout));

  cl_command_queue command_q =
      clCreateCommandQueue(context, device, 0, &errcode);
  EXPECT_TRUE(command_q);
  ASSERT_SUCCESS(errcode);

  UCL::vector<cl_int> inData(elements);
  for (cl_int i = 0; i < static_cast<cl_int>(elements); ++i) {
    inData[i] = i;
  }

  ASSERT_SUCCESS(clEnqueueWriteBuffer(command_q, bufin, CL_TRUE, 0, buflen,
                                      inData.data(), 0, nullptr, nullptr));
  cl_event ndRangeEvent;
  ASSERT_SUCCESS(clEnqueueNDRangeKernel(command_q, kernel, 1, nullptr,
                                        &elements, nullptr, 0, nullptr,
                                        &ndRangeEvent));
  cl_event readEvent;
  UCL::vector<cl_int> outData(elements);
  ASSERT_SUCCESS(clEnqueueReadBuffer(command_q, bufout, CL_TRUE, 0, buflen,
                                     outData.data(), 1, &ndRangeEvent,
                                     &readEvent));
  ASSERT_SUCCESS(clWaitForEvents(1, &readEvent));
  for (size_t i = 0; i < elements; ++i) {
    EXPECT_EQ(inData[i], outData[i]);
  }

  ASSERT_SUCCESS(clReleaseEvent(readEvent));
  ASSERT_SUCCESS(clReleaseEvent(ndRangeEvent));
  ASSERT_SUCCESS(clReleaseCommandQueue(command_q));
  ASSERT_SUCCESS(clReleaseKernel(kernel));
  ASSERT_SUCCESS(clReleaseMemObject(bufout));
  ASSERT_SUCCESS(clReleaseMemObject(bufin));
}

// The same as DefaultNDRangeKernel, but with many threads.
TEST_F(clCreateProgramWithBinaryTest, ConcurrentNDRangeKernel) {
  auto worker = [&]() {
    UCL::vector<cl_int> status;
    status.resize(1);

    cl_int errcode = !CL_SUCCESS;

    cl_program program =
        clCreateProgramWithBinary(context, 1, &device, binaryLengths.data(),
                                  binaries, status.data(), &errcode);
    EXPECT_TRUE(program);
    ASSERT_SUCCESS(errcode);

    size_t elements = 64;
    size_t buflen = elements * sizeof(cl_int);

    cl_mem bufin =
        clCreateBuffer(context, CL_MEM_READ_ONLY, buflen, nullptr, &errcode);
    EXPECT_TRUE(bufin);
    ASSERT_SUCCESS(errcode);

    cl_mem bufout =
        clCreateBuffer(context, CL_MEM_WRITE_ONLY, buflen, nullptr, &errcode);
    EXPECT_TRUE(bufout);
    ASSERT_SUCCESS(errcode);

    cl_kernel kernel = clCreateKernel(program, "foo", &errcode);
    EXPECT_TRUE(kernel);
    ASSERT_SUCCESS(errcode);

    ASSERT_SUCCESS(clSetKernelArg(kernel, 0, sizeof(cl_mem), &bufin));
    ASSERT_SUCCESS(clSetKernelArg(kernel, 1, sizeof(cl_mem), &bufout));

    cl_command_queue command_q =
        clCreateCommandQueue(context, device, 0, &errcode);
    EXPECT_TRUE(command_q);
    ASSERT_SUCCESS(errcode);

    UCL::vector<cl_int> inData(elements);
    for (cl_int i = 0; i < static_cast<cl_int>(elements); ++i) {
      inData[i] = i;
    }

    ASSERT_SUCCESS(clEnqueueWriteBuffer(command_q, bufin, CL_TRUE, 0, buflen,
                                        inData.data(), 0, nullptr, nullptr));
    cl_event ndRangeEvent;
    ASSERT_SUCCESS(clEnqueueNDRangeKernel(command_q, kernel, 1, nullptr,
                                          &elements, nullptr, 0, nullptr,
                                          &ndRangeEvent));
    cl_event readEvent;
    UCL::vector<cl_int> outData(elements);
    ASSERT_SUCCESS(clEnqueueReadBuffer(command_q, bufout, CL_TRUE, 0, buflen,
                                       outData.data(), 1, &ndRangeEvent,
                                       &readEvent));
    ASSERT_SUCCESS(clWaitForEvents(1, &readEvent));
    for (size_t i = 0; i < elements; ++i) {
      EXPECT_EQ(inData[i], outData[i]);
    }

    ASSERT_SUCCESS(clReleaseEvent(readEvent));
    ASSERT_SUCCESS(clReleaseEvent(ndRangeEvent));
    ASSERT_SUCCESS(clReleaseCommandQueue(command_q));
    ASSERT_SUCCESS(clReleaseKernel(kernel));
    ASSERT_SUCCESS(clReleaseMemObject(bufout));
    ASSERT_SUCCESS(clReleaseMemObject(bufin));
    ASSERT_SUCCESS(clReleaseProgram(program));
  };

  // Ideally there would be 10+ threads as that is much more reliable for
  // detecting issues, but greatly slows down the test.  Even at 10 threads
  // issues will sometimes trigger, so issues will be caught sooner or later.
  // If the thread sanitizer is enabled then 2 is conceivably enough. The
  // non-LLVM code path used by this test is so light, that more threads are
  // needed here than in other *Concurrent* tests to find races.
  const size_t threads = 10;
  UCL::vector<std::thread> workers(threads);

  for (size_t i = 0; i < threads; i++) {
    workers[i] = std::thread(worker);
  }

  for (size_t i = 0; i < threads; i++) {
    workers[i].join();
  }
}

// The same as DefaultNDRangeKernel, but with SPIR.
TEST_F(clCreateProgramWithBinaryTest, DefaultNDRangeSpirKernel) {
  if (!UCL::hasCompilerSupport(device)) {
    GTEST_SKIP();
  }

  cl_int errcode = !CL_SUCCESS;

  cl_uint bits;
  errcode = clGetDeviceInfo(device, CL_DEVICE_ADDRESS_BITS, sizeof(cl_uint),
                            &bits, nullptr);
  ASSERT_SUCCESS(errcode);
  ASSERT_TRUE((bits == 32) || (bits == 64));

  size_t len = (bits == 32) ? source_bc32_len : source_bc64_len;
  const unsigned char *data = (bits == 32) ? source_bc32 : source_bc64;

  program = clCreateProgramWithBinary(context, 1, &device, &len, &data,
                                      binaryStatii.data(), &errcode);
  EXPECT_TRUE(program);
  ASSERT_SUCCESS(errcode);

  ASSERT_SUCCESS(clBuildProgram(program, 0, nullptr, "-x spir -spir-std=1.2",
                                nullptr, nullptr));

  size_t elements = 64;
  size_t buflen = elements * sizeof(cl_int);

  cl_mem bufin =
      clCreateBuffer(context, CL_MEM_READ_ONLY, buflen, nullptr, &errcode);
  EXPECT_TRUE(bufin);
  ASSERT_SUCCESS(errcode);

  cl_mem bufout =
      clCreateBuffer(context, CL_MEM_WRITE_ONLY, buflen, nullptr, &errcode);
  EXPECT_TRUE(bufout);
  ASSERT_SUCCESS(errcode);

  cl_kernel kernel = clCreateKernel(program, "foo", &errcode);
  EXPECT_TRUE(kernel);
  ASSERT_SUCCESS(errcode);

  ASSERT_SUCCESS(clSetKernelArg(kernel, 0, sizeof(cl_mem), &bufin));
  ASSERT_SUCCESS(clSetKernelArg(kernel, 1, sizeof(cl_mem), &bufout));

  cl_command_queue command_q =
      clCreateCommandQueue(context, device, 0, &errcode);
  EXPECT_TRUE(command_q);
  ASSERT_SUCCESS(errcode);

  UCL::vector<cl_int> inData(elements);
  for (cl_int i = 0; i < static_cast<cl_int>(elements); ++i) {
    inData[i] = i;
  }

  ASSERT_SUCCESS(clEnqueueWriteBuffer(command_q, bufin, CL_TRUE, 0, buflen,
                                      inData.data(), 0, nullptr, nullptr));
  cl_event ndRangeEvent;
  ASSERT_SUCCESS(clEnqueueNDRangeKernel(command_q, kernel, 1, nullptr,
                                        &elements, nullptr, 0, nullptr,
                                        &ndRangeEvent));
  cl_event readEvent;
  UCL::vector<cl_int> outData(elements);
  ASSERT_SUCCESS(clEnqueueReadBuffer(command_q, bufout, CL_TRUE, 0, buflen,
                                     outData.data(), 1, &ndRangeEvent,
                                     &readEvent));
  ASSERT_SUCCESS(clWaitForEvents(1, &readEvent));
  for (size_t i = 0; i < elements; ++i) {
    EXPECT_EQ(inData[i], outData[i]);
  }

  ASSERT_SUCCESS(clReleaseEvent(readEvent));
  ASSERT_SUCCESS(clReleaseEvent(ndRangeEvent));
  ASSERT_SUCCESS(clReleaseCommandQueue(command_q));
  ASSERT_SUCCESS(clReleaseKernel(kernel));
  ASSERT_SUCCESS(clReleaseMemObject(bufout));
  ASSERT_SUCCESS(clReleaseMemObject(bufin));
}

// The same as DefaultNDRangeSpirKernel, but calls clCompileProgram() and
// clLinkProgram() instead of clBuildProgram()
TEST_F(clCreateProgramWithBinaryTest, DefaultNDRangeSpirKernelCompileLink) {
  if (!UCL::hasCompilerSupport(device)) {
    GTEST_SKIP();
  }

  cl_int errcode = !CL_SUCCESS;

  cl_uint bits;
  errcode = clGetDeviceInfo(device, CL_DEVICE_ADDRESS_BITS, sizeof(cl_uint),
                            &bits, nullptr);
  ASSERT_SUCCESS(errcode);
  ASSERT_TRUE((bits == 32) || (bits == 64));

  size_t len = (bits == 32) ? source_bc32_len : source_bc64_len;
  const unsigned char *data = (bits == 32) ? source_bc32 : source_bc64;

  program = clCreateProgramWithBinary(context, 1, &device, &len, &data,
                                      binaryStatii.data(), &errcode);
  EXPECT_TRUE(program);
  ASSERT_SUCCESS(errcode);

  ASSERT_SUCCESS(clCompileProgram(program, 0, nullptr, "-x spir -spir-std=1.2",
                                  0, nullptr, nullptr, nullptr, nullptr));

  cl_program linked_program = clLinkProgram(
      context, 0, nullptr, nullptr, 1, &program, nullptr, nullptr, &errcode);
  ASSERT_SUCCESS(errcode);

  size_t elements = 64;
  size_t buflen = elements * sizeof(cl_int);

  cl_mem bufin =
      clCreateBuffer(context, CL_MEM_READ_ONLY, buflen, nullptr, &errcode);
  EXPECT_TRUE(bufin);
  ASSERT_SUCCESS(errcode);

  cl_mem bufout =
      clCreateBuffer(context, CL_MEM_WRITE_ONLY, buflen, nullptr, &errcode);
  EXPECT_TRUE(bufout);
  ASSERT_SUCCESS(errcode);

  cl_kernel kernel = clCreateKernel(linked_program, "foo", &errcode);
  EXPECT_TRUE(kernel);
  ASSERT_SUCCESS(errcode);

  ASSERT_SUCCESS(clSetKernelArg(kernel, 0, sizeof(cl_mem), &bufin));
  ASSERT_SUCCESS(clSetKernelArg(kernel, 1, sizeof(cl_mem), &bufout));

  cl_command_queue command_q =
      clCreateCommandQueue(context, device, 0, &errcode);
  EXPECT_TRUE(command_q);
  ASSERT_SUCCESS(errcode);

  UCL::vector<cl_int> inData(elements);
  for (cl_int i = 0; i < static_cast<cl_int>(elements); ++i) {
    inData[i] = i;
  }

  ASSERT_SUCCESS(clEnqueueWriteBuffer(command_q, bufin, CL_TRUE, 0, buflen,
                                      inData.data(), 0, nullptr, nullptr));
  cl_event ndRangeEvent;
  ASSERT_SUCCESS(clEnqueueNDRangeKernel(command_q, kernel, 1, nullptr,
                                        &elements, nullptr, 0, nullptr,
                                        &ndRangeEvent));
  cl_event readEvent;
  UCL::vector<cl_int> outData(elements);
  ASSERT_SUCCESS(clEnqueueReadBuffer(command_q, bufout, CL_TRUE, 0, buflen,
                                     outData.data(), 1, &ndRangeEvent,
                                     &readEvent));
  ASSERT_SUCCESS(clWaitForEvents(1, &readEvent));
  for (size_t i = 0; i < elements; ++i) {
    EXPECT_EQ(inData[i], outData[i]);
  }

  ASSERT_SUCCESS(clReleaseEvent(readEvent));
  ASSERT_SUCCESS(clReleaseEvent(ndRangeEvent));
  ASSERT_SUCCESS(clReleaseCommandQueue(command_q));
  ASSERT_SUCCESS(clReleaseKernel(kernel));
  ASSERT_SUCCESS(clReleaseProgram(linked_program));
  ASSERT_SUCCESS(clReleaseMemObject(bufout));
  ASSERT_SUCCESS(clReleaseMemObject(bufin));
}

// The same as DefaultNDRangeSpirKernel, but with many threads.
TEST_F(clCreateProgramWithBinaryTest, ConcurrentNDRangeSpirKernel) {
  if (!UCL::hasCompilerSupport(device)) {
    GTEST_SKIP();
  }

  cl_int errcode = !CL_SUCCESS;

  cl_uint bits;
  errcode = clGetDeviceInfo(device, CL_DEVICE_ADDRESS_BITS, sizeof(cl_uint),
                            &bits, nullptr);
  ASSERT_SUCCESS(errcode);
  ASSERT_TRUE((bits == 32) || (bits == 64));

  size_t len = (bits == 32) ? source_bc32_len : source_bc64_len;
  const unsigned char *data = (bits == 32) ? source_bc32 : source_bc64;

  auto worker = [&]() {
    UCL::vector<cl_int> status;
    status.resize(1);

    cl_int errcode = !CL_SUCCESS;
    cl_program program = clCreateProgramWithBinary(
        context, 1, &device, &len, &data, status.data(), &errcode);
    EXPECT_TRUE(program);
    ASSERT_SUCCESS(errcode);

    ASSERT_SUCCESS(clBuildProgram(program, 0, nullptr, "-x spir -spir-std=1.2",
                                  nullptr, nullptr));

    size_t elements = 64;
    size_t buflen = elements * sizeof(cl_int);

    cl_mem bufin =
        clCreateBuffer(context, CL_MEM_READ_ONLY, buflen, nullptr, &errcode);
    EXPECT_TRUE(bufin);
    ASSERT_SUCCESS(errcode);

    cl_mem bufout =
        clCreateBuffer(context, CL_MEM_WRITE_ONLY, buflen, nullptr, &errcode);
    EXPECT_TRUE(bufout);
    ASSERT_SUCCESS(errcode);

    cl_kernel kernel = clCreateKernel(program, "foo", &errcode);
    EXPECT_TRUE(kernel);
    ASSERT_SUCCESS(errcode);

    ASSERT_SUCCESS(clSetKernelArg(kernel, 0, sizeof(cl_mem), &bufin));
    ASSERT_SUCCESS(clSetKernelArg(kernel, 1, sizeof(cl_mem), &bufout));

    cl_command_queue command_q =
        clCreateCommandQueue(context, device, 0, &errcode);
    EXPECT_TRUE(command_q);
    ASSERT_SUCCESS(errcode);

    UCL::vector<cl_int> inData(elements);
    for (cl_int i = 0; i < static_cast<cl_int>(elements); ++i) {
      inData[i] = i;
    }

    ASSERT_SUCCESS(clEnqueueWriteBuffer(command_q, bufin, CL_TRUE, 0, buflen,
                                        inData.data(), 0, nullptr, nullptr));
    cl_event ndRangeEvent;
    ASSERT_SUCCESS(clEnqueueNDRangeKernel(command_q, kernel, 1, nullptr,
                                          &elements, nullptr, 0, nullptr,
                                          &ndRangeEvent));
    cl_event readEvent;
    UCL::vector<cl_int> outData(elements);
    ASSERT_SUCCESS(clEnqueueReadBuffer(command_q, bufout, CL_TRUE, 0, buflen,
                                       outData.data(), 1, &ndRangeEvent,
                                       &readEvent));
    ASSERT_SUCCESS(clWaitForEvents(1, &readEvent));
    for (size_t i = 0; i < elements; ++i) {
      EXPECT_EQ(inData[i], outData[i]);
    }

    ASSERT_SUCCESS(clReleaseEvent(readEvent));
    ASSERT_SUCCESS(clReleaseEvent(ndRangeEvent));
    ASSERT_SUCCESS(clReleaseCommandQueue(command_q));
    ASSERT_SUCCESS(clReleaseKernel(kernel));
    ASSERT_SUCCESS(clReleaseMemObject(bufout));
    ASSERT_SUCCESS(clReleaseMemObject(bufin));
    ASSERT_SUCCESS(clReleaseProgram(program));
  };

  // Ideally there would be 10+ threads as that is much more reliable for
  // detecting issues, but greatly slows down the test.  Even at 10 threads
  // issues will sometimes trigger, so issues will be caught sooner or later.
  // If the thread sanitizer is enabled then 2 is conceivably enough.
  const size_t threads = 5;
  UCL::vector<std::thread> workers(threads);

  for (size_t i = 0; i < threads; i++) {
    workers[i] = std::thread(worker);
  }

  for (size_t i = 0; i < threads; i++) {
    workers[i].join();
  }
}

TEST_F(clCreateProgramWithBinaryTest, CorruptSpirKernel) {
  cl_int errcode = !CL_SUCCESS;

  cl_uint bits;
  errcode = clGetDeviceInfo(device, CL_DEVICE_ADDRESS_BITS, sizeof(cl_uint),
                            &bits, nullptr);
  ASSERT_SUCCESS(errcode);
  ASSERT_TRUE((bits == 32) || (bits == 64));

  size_t len = (bits == 32) ? source_bc32_len : source_bc64_len;
  const unsigned char *data = (bits == 32) ? source_bc32 : source_bc64;

  // Copy the SPIR into a local vector so as we can modify it.
  std::vector<unsigned char> copy(len);
  copy.assign(data, data + len);

  // Corrupt the data just enough such that LLVM still thinks that it is IR to
  // start with (i.e. the first four bytes of magic number are intact), corrupt
  // enough that it can't parse it, but not so much that it triggers internal
  // LLVM assertions or crashes.
  copy[5] = '\0';

  const unsigned char *corrupt_data = copy.data();

  program = clCreateProgramWithBinary(context, 1, &device, &len, &corrupt_data,
                                      binaryStatii.data(), &errcode);
  EXPECT_FALSE(program);
  ASSERT_EQ_ERRCODE(CL_INVALID_BINARY, errcode);
}

TEST_F(clCreateProgramWithBinaryTest, CreateProgramThenTryCompile) {
  cl_int errcode = !CL_SUCCESS;
  program = clCreateProgramWithBinary(context, 1, &device, binaryLengths.data(),
                                      binaries, binaryStatii.data(), &errcode);
  EXPECT_TRUE(program);
  ASSERT_SUCCESS(errcode);

  const size_t num_devices = 1;
  cl_device_id *devices = &device;

  for (size_t i = 0; i < num_devices; ++i) {
    ASSERT_SUCCESS(binaryStatii[i]);
  }

  for (size_t i = 0; i < num_devices; ++i) {
    cl_device_id device = devices[i];

    errcode = clCompileProgram(program, 1, &device, nullptr, 0, nullptr,
                               nullptr, nullptr, nullptr);
    if (UCL::hasCompilerSupport(device)) {
      ASSERT_EQ_ERRCODE(CL_INVALID_OPERATION, errcode);
    } else {
      ASSERT_EQ_ERRCODE(CL_COMPILER_NOT_AVAILABLE, errcode);
    }
  }
}

TEST_F(clCreateProgramWithBinaryTest, CreateProgramThenTryBuild) {
  cl_int errcode = !CL_SUCCESS;
  program = clCreateProgramWithBinary(context, 1, &device, binaryLengths.data(),
                                      binaries, binaryStatii.data(), &errcode);
  EXPECT_TRUE(program);
  ASSERT_SUCCESS(errcode);

  for (unsigned i = 0; i < 1; ++i) {
    ASSERT_SUCCESS(binaryStatii[i]);
  }

  ASSERT_SUCCESS(
      clBuildProgram(program, 1, &device, nullptr, nullptr, nullptr));
}

// Redmine #5134: test binary of library, which should fail when build program
// called on it

#if defined(CL_VERSION_3_0)
TEST_F(clCreateProgramWithBinaryTest, IL) {
  // Skip for non OpenCL-3.0 implementations.
  if (!UCL::isDeviceVersionAtLeast({3, 0})) {
    GTEST_SKIP();
  }

  cl_int errcode;
  program = clCreateProgramWithBinary(context, 1, &device, binaryLengths.data(),
                                      binaries, binaryStatii.data(), &errcode);
  ASSERT_SUCCESS(errcode);
  ASSERT_NE(program, nullptr);

  // Query for size of value.
  size_t size{};
  ASSERT_SUCCESS(clGetProgramInfo(program, CL_PROGRAM_IL, 0, nullptr, &size));

  //  If program is created with clCreateProgramWithSource,
  //  clCreateProgramWithBinary or clCreateProgramWithBuiltInKernels the memory
  //  pointed to by param_value will be unchanged and param_value_size_ret will
  //  be set to 0.
  ASSERT_EQ(size, 0);
  UCL::Buffer<char> param_val{1};
  param_val[0] = 42;
  ASSERT_SUCCESS(clGetProgramInfo(program, CL_PROGRAM_IL, param_val.size(),
                                  param_val.data(), nullptr));
  ASSERT_EQ(param_val[0], 42);
}
#endif
